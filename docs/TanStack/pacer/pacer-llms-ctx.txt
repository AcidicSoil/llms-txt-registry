<project title="Pacer" summary="TanStack Pacer is a lightweight, type-safe library designed to manage asynchronous operations with precision, offering utilities for debouncing, throttling, rate limiting, queuing, and batching. Its primary goal is to help developers control the timing and scheduling of async functions to prevent performance bottlenecks, reduce unnecessary API calls, and improve user experience. It supports multiple frameworks (React, Solid) and includes developer tools for inspecting async state, making it ideal for modern frontend applications that require fine-grained control over async behavior.">**Remember:**
- Debouncing
- Throttling
- Rate Limiting
- Queuing
- Batching
- Async Workflows<docs><doc title="Installation" desc="install &amp; quickstart.">---
title: Installation
id: installation
---

You can install TanStack Pacer with any [NPM](https://npmjs.com) package manager.

Only install one of the following packages depending on your use case:

## React

```sh
npm install @tanstack/react-pacer
```

TanStack Pacer is compatible with React v16.8+

## Solid

```sh
npm install @tanstack/solid-pacer
```

TanStack Pacer is compatible with Solid v1.9.5+

## Vanilla JS

```sh
npm install @tanstack/pacer
```

Install the the core `@tanstack/pacer` package to use with any framework or without a framework. Each framework package up above will also re-export everything from this core package.

> [!IMPORTANT] There's no need to install the `@tanstack/pacer` core package if you've already installed one of the above framework packages.

## Devtools (Optional)

To use the devtools for debugging and monitoring, install both the framework devtools and the Pacer devtools packages:

### React Devtools

```sh
npm install @tanstack/react-devtools @tanstack/react-pacer-devtools
```

### Solid Devtools

```sh
npm install @tanstack/solid-devtools @tanstack/solid-pacer-devtools
```

See the [devtools](https://pacer.tanstack.com/docs/devtools) documentation for more information on how to set up and use the Pacer devtools.</doc><doc title="Overview" desc="install &amp; quickstart.">---
title: Overview
id: overview
---

TanStack Pacer is a library focused on providing high-quality utilities for controlling function execution timing in your applications. While similar utilities exist elsewhere, we aim to get all the important details right - including ***type-safety***, ***tree-shaking***, and a consistent and ***intuitive API***. By focusing on these fundamentals and making them available in a ***framework agnostic*** way, we hope to make these utilities and patterns more commonplace in your applications. Proper execution control is often an afterthought in application development, leading to performance issues, race conditions, and poor user experiences that could have been prevented. TanStack Pacer helps you implement these critical patterns correctly from the start!

> [!IMPORTANT]
> TanStack Pacer is currently in **alpha** and its API is subject to change.
>
> The scope of this library may grow, but we hope to keep the bundle size of each individual utility lean and focused.

## Origin

Many of the ideas (and code) for TanStack Pacer are not new. In fact, many of these utilities have been living in other TanStack libraries for quite some time. We extracted code from TanStack Query, Router, Form, and even Tanner's original [Swimmer](https://github.com/tannerlinsley/swimmer) library. Then we cleaned up these utilities, filled in some gaps, and shipped them as a standalone library.

## Features

> [!NOTE]
> TanStack Pacer is currently mostly a client-side only library, but it is being designed to be able to potentially be used on the server-side as well.

- **Debouncing**
  - Delay execution until after a period of inactivity for when you only care about the last execution in a sequence.
  - Synchronous or Asynchronous Debounce utilities with promise support and error handling
  - Control of leading, trailing, and enabled options
- **Throttling**
  - Smoothly limit the rate at which a function can fire
  - Synchronous or Asynchronous Throttle utilities with promise support and error handling
  - Control of leading, trailing, and enabled options.
- **Rate Limiting**
  - Limit the rate at which a function can fire over a period of time
  - Synchronous or Asynchronous Rate Limiting utilities with promise support and error handling
  - Fixed or Sliding Window variations of Rate Limiting
- **Queuing**
  - Queue functions to be executed in a specific order
  - Choose from FIFO, LIFO, and Priority queue implementations
  - Control processing speed with configurable wait times or concurrency limits
  - Manage queue execution with start/stop capabilities
  - Expire items from the queue after a configurable duration
- **Batching**
  - Chunk up multiple operations into larger batches to reduce total back-and-forth operations
  - Batch by time period, batch size, whichever comes first, or a custom condition to trigger batch executions
- **Async or Sync Variations**
  - Choose between synchronous and asynchronous versions of each utility
  - Optional error, success, and settled handling for async variations
- **State Management**
  - Uses TanStack Store under the hood for state management with fine-grained reactivity
  - Easily integrate with your own state management library of choice
  - Persist state to local or session storage for some utilities like rate limiting and queuing
- **Convenient Hooks**
  - Reduce boilerplate code with pre-built hooks like `useDebouncedCallback`, `useThrottledValue`, and `useQueuedState`, and more.
  - Multiple layers of abstraction to choose from depending on your use case.
  - Works with each framework's default state management solutions, or with whatever custom state management library that you prefer.
- **Type Safety**
  - Full type safety with TypeScript that makes sure that your functions will always be called with the correct arguments
  - Generics for flexible and reusable utilities
- **Framework Adapters**
  - React, Solid, and more
- **Tree Shaking**
  - We, of course, get tree-shaking right for your applications by default, but we also provide extra deep imports for each utility, making it easier to embed these utilities into your libraries without increasing the bundle-phobia reports of your library.

## Interactive Comparison Demo

Each utility is designed to be used in a specific way, and each utility has its own unique behavior.

See how each utility behaves with this interactive comparison. Move the range slider to observe the differences between debouncing, throttling, rate limiting, queuing, and batching:

<iframe src="https://stackblitz.com/github/TanStack/pacer/tree/main/examples/react/util-comparison?embed=1&view=preview&hideNavigation=1" width="100%" height="1200px" style="border: 1px solid #ccc; border-radius: 4px;"></iframe></doc><doc title="Reference" desc="API reference.">---
id: "@tanstack/pacer"
title: "@tanstack/pacer"
---


# @tanstack/pacer

## Classes

- [AsyncBatcher](../classes/asyncbatcher.md)
- [AsyncDebouncer](../classes/asyncdebouncer.md)
- [AsyncQueuer](../classes/asyncqueuer.md)
- [AsyncRateLimiter](../classes/asyncratelimiter.md)
- [AsyncRetryer](../classes/asyncretryer.md)
- [AsyncThrottler](../classes/asyncthrottler.md)
- [Batcher](../classes/batcher.md)
- [Debouncer](../classes/debouncer.md)
- [Queuer](../classes/queuer.md)
- [RateLimiter](../classes/ratelimiter.md)
- [Throttler](../classes/throttler.md)

## Interfaces

- [AsyncBatcherOptions](../interfaces/asyncbatcheroptions.md)
- [AsyncBatcherState](../interfaces/asyncbatcherstate.md)
- [AsyncDebouncerOptions](../interfaces/asyncdebounceroptions.md)
- [AsyncDebouncerState](../interfaces/asyncdebouncerstate.md)
- [AsyncQueuerOptions](../interfaces/asyncqueueroptions.md)
- [AsyncQueuerState](../interfaces/asyncqueuerstate.md)
- [AsyncRateLimiterOptions](../interfaces/asyncratelimiteroptions.md)
- [AsyncRateLimiterState](../interfaces/asyncratelimiterstate.md)
- [AsyncRetryerOptions](../interfaces/asyncretryeroptions.md)
- [AsyncRetryerState](../interfaces/asyncretryerstate.md)
- [AsyncThrottlerOptions](../interfaces/asyncthrottleroptions.md)
- [AsyncThrottlerState](../interfaces/asyncthrottlerstate.md)
- [BatcherOptions](../interfaces/batcheroptions.md)
- [BatcherState](../interfaces/batcherstate.md)
- [DebouncerOptions](../interfaces/debounceroptions.md)
- [DebouncerState](../interfaces/debouncerstate.md)
- [PacerEventMap](../interfaces/pacereventmap.md)
- [QueuerOptions](../interfaces/queueroptions.md)
- [QueuerState](../interfaces/queuerstate.md)
- [RateLimiterOptions](../interfaces/ratelimiteroptions.md)
- [RateLimiterState](../interfaces/ratelimiterstate.md)
- [ThrottlerOptions](../interfaces/throttleroptions.md)
- [ThrottlerState](../interfaces/throttlerstate.md)

## Type Aliases

- [AnyAsyncFunction](../type-aliases/anyasyncfunction.md)
- [AnyFunction](../type-aliases/anyfunction.md)
- [OptionalKeys](../type-aliases/optionalkeys.md)
- [PacerEventName](../type-aliases/pacereventname.md)
- [QueuePosition](../type-aliases/queueposition.md)

## Variables

- [pacerEventClient](../variables/pacereventclient.md)

## Functions

- [asyncBatch](../functions/asyncbatch.md)
- [asyncBatcherOptions](../functions/asyncbatcheroptions.md)
- [asyncDebounce](../functions/asyncdebounce.md)
- [asyncDebouncerOptions](../functions/asyncdebounceroptions.md)
- [asyncQueue](../functions/asyncqueue.md)
- [asyncQueuerOptions](../functions/asyncqueueroptions.md)
- [asyncRateLimit](../functions/asyncratelimit.md)
- [asyncRateLimiterOptions](../functions/asyncratelimiteroptions.md)
- [asyncRetry](../functions/asyncretry.md)
- [asyncRetryerOptions](../functions/asyncretryeroptions.md)
- [asyncThrottle](../functions/asyncthrottle.md)
- [asyncThrottlerOptions](../functions/asyncthrottleroptions.md)
- [batch](../functions/batch.md)
- [createKey](../functions/createkey.md)
- [debounce](../functions/debounce.md)
- [debouncerOptions](../functions/debounceroptions.md)
- [isFunction](../functions/isfunction.md)
- [parseFunctionOrValue](../functions/parsefunctionorvalue.md)
- [queue](../functions/queue.md)
- [queuerOptions](../functions/queueroptions.md)
- [rateLimit](../functions/ratelimit.md)
- [rateLimiterOptions](../functions/ratelimiteroptions.md)
- [throttle](../functions/throttle.md)
- [throttlerOptions](../functions/throttleroptions.md)</doc><doc title="Reference" desc="API reference.">---
id: "@tanstack/react-pacer"
title: "@tanstack/react-pacer"
---


# @tanstack/react-pacer

## Interfaces

- [PacerProviderOptions](../interfaces/pacerprovideroptions.md)
- [PacerProviderProps](../interfaces/pacerproviderprops.md)
- [ReactAsyncBatcher](../interfaces/reactasyncbatcher.md)
- [ReactAsyncDebouncer](../interfaces/reactasyncdebouncer.md)
- [ReactAsyncQueuer](../interfaces/reactasyncqueuer.md)
- [ReactAsyncRateLimiter](../interfaces/reactasyncratelimiter.md)
- [ReactAsyncThrottler](../interfaces/reactasyncthrottler.md)
- [ReactBatcher](../interfaces/reactbatcher.md)
- [ReactDebouncer](../interfaces/reactdebouncer.md)
- [ReactQueuer](../interfaces/reactqueuer.md)
- [ReactRateLimiter](../interfaces/reactratelimiter.md)
- [ReactThrottler](../interfaces/reactthrottler.md)

## Functions

- [PacerProvider](../functions/pacerprovider.md)
- [useAsyncBatchedCallback](../functions/useasyncbatchedcallback.md)
- [useAsyncBatcher](../functions/useasyncbatcher.md)
- [useAsyncDebouncedCallback](../functions/useasyncdebouncedcallback.md)
- [useAsyncDebouncer](../functions/useasyncdebouncer.md)
- [useAsyncQueuedState](../functions/useasyncqueuedstate.md)
- [useAsyncQueuer](../functions/useasyncqueuer.md)
- [useAsyncRateLimitedCallback](../functions/useasyncratelimitedcallback.md)
- [useAsyncRateLimiter](../functions/useasyncratelimiter.md)
- [useAsyncThrottledCallback](../functions/useasyncthrottledcallback.md)
- [useAsyncThrottler](../functions/useasyncthrottler.md)
- [useBatchedCallback](../functions/usebatchedcallback.md)
- [useBatcher](../functions/usebatcher.md)
- [useDebouncedCallback](../functions/usedebouncedcallback.md)
- [useDebouncedState](../functions/usedebouncedstate.md)
- [useDebouncedValue](../functions/usedebouncedvalue.md)
- [useDebouncer](../functions/usedebouncer.md)
- [useDefaultPacerOptions](../functions/usedefaultpaceroptions.md)
- [usePacerContext](../functions/usepacercontext.md)
- [useQueuedState](../functions/usequeuedstate.md)
- [useQueuedValue](../functions/usequeuedvalue.md)
- [useQueuer](../functions/usequeuer.md)
- [useRateLimitedCallback](../functions/useratelimitedcallback.md)
- [useRateLimitedState](../functions/useratelimitedstate.md)
- [useRateLimitedValue](../functions/useratelimitedvalue.md)
- [useRateLimiter](../functions/useratelimiter.md)
- [useThrottledCallback](../functions/usethrottledcallback.md)
- [useThrottledState](../functions/usethrottledstate.md)
- [useThrottledValue](../functions/usethrottledvalue.md)
- [useThrottler](../functions/usethrottler.md)</doc><doc title="Reference" desc="API reference.">---
id: "@tanstack/solid-pacer"
title: "@tanstack/solid-pacer"
---


# @tanstack/solid-pacer

## Interfaces

- [SolidAsyncBatcher](../interfaces/solidasyncbatcher.md)
- [SolidAsyncDebouncer](../interfaces/solidasyncdebouncer.md)
- [SolidAsyncQueuer](../interfaces/solidasyncqueuer.md)
- [SolidAsyncRateLimiter](../interfaces/solidasyncratelimiter.md)
- [SolidAsyncThrottler](../interfaces/solidasyncthrottler.md)
- [SolidBatcher](../interfaces/solidbatcher.md)
- [SolidDebouncer](../interfaces/soliddebouncer.md)
- [SolidQueuer](../interfaces/solidqueuer.md)
- [SolidRateLimiter](../interfaces/solidratelimiter.md)
- [SolidThrottler](../interfaces/solidthrottler.md)

## Functions

- [createAsyncBatcher](../functions/createasyncbatcher.md)
- [createAsyncDebouncer](../functions/createasyncdebouncer.md)
- [createAsyncQueuer](../functions/createasyncqueuer.md)
- [createAsyncRateLimiter](../functions/createasyncratelimiter.md)
- [createAsyncThrottler](../functions/createasyncthrottler.md)
- [createBatcher](../functions/createbatcher.md)
- [createDebouncedSignal](../functions/createdebouncedsignal.md)
- [createDebouncedValue](../functions/createdebouncedvalue.md)
- [createDebouncer](../functions/createdebouncer.md)
- [createQueuer](../functions/createqueuer.md)
- [createRateLimitedSignal](../functions/createratelimitedsignal.md)
- [createRateLimitedValue](../functions/createratelimitedvalue.md)
- [createRateLimiter](../functions/createratelimiter.md)
- [createThrottledSignal](../functions/createthrottledsignal.md)
- [createThrottledValue](../functions/createthrottledvalue.md)
- [createThrottler](../functions/createthrottler.md)</doc><doc title="Devtools" desc="docs page.">---
title: Devtools
id: devtools
---

What? My debouncer can have dedicated devtools? Yep!

TanStack Pacer provides devtools for debugging and monitoring all your utilities in real-time. The devtools integrate seamlessly within the new [TanStack Devtools](https://tanstack.com/devtools) multi-panel UI.

> [!NOTE] By default, the TanStack Devtools and TanStack Pacer Devtools will only be included in development mode. This helps keep your production bundle size minimal. If you need to include devtools in production builds (e.g., for debugging production issues), you can use the alternative "production" imports.

## Installation

Install the devtools packages for your framework:

### React

```sh
npm install @tanstack/react-devtools @tanstack/react-pacer-devtools
```

### Solid

```sh
npm install @tanstack/solid-devtools @tanstack/solid-pacer-devtools
```

## Basic Setup

### React Setup

```tsx
import { TanStackDevtools } from '@tanstack/react-devtools'
import { pacerDevtoolsPlugin } from '@tanstack/react-pacer-devtools'

function App() {
  return (
    <div>
      {/* Your app content */}
      
      <TanStackDevtools
        eventBusConfig={{
          debug: false,
        }}
        plugins={[pacerDevtoolsPlugin()]}
      />
    </div>
  )
}
```

### Solid Setup

```tsx
import { TanStackDevtools } from '@tanstack/solid-devtools'
import { pacerDevtoolsPlugin } from '@tanstack/solid-pacer-devtools'

function App() {
  return (
    <div>
      {/* Your app content */}
      
      <TanStackDevtools
        eventBusConfig={{
          debug: false,
        }}
        plugins={[pacerDevtoolsPlugin()]}
      />
    </div>
  )
}
```

## Production Builds

By default, devtools are excluded from production builds to minimize bundle size. The default imports will return no-op implementations in production:

```tsx
// This will be a no-op in production builds
import { pacerDevtoolsPlugin } from '@tanstack/react-pacer-devtools'
```

If you need to include devtools in production builds (e.g., for debugging production issues), use the production-specific imports:

```tsx
// This will include full devtools even in production builds
import { pacerDevtoolsPlugin } from '@tanstack/react-pacer-devtools/production'
```

## Registering Utilities

Each utility should automatically be detected and displayed in the devtools. However, if you don't provide a `key` option to the utility, it will show with a uuid for its name. Give it an identifiable name with the `key` option.

```tsx
const debouncer = new Debouncer(myDebounceFn, {
  key: 'My Debouncer', // friendly name for the utility instead of auto-generated uuid
  wait: 1000,
})
```</doc><doc title="Generatedocs" desc="docs page.">import { resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { readFileSync, writeFileSync } from 'node:fs'
import { generateReferenceDocs } from '@tanstack/config/typedoc'

import fg from 'fast-glob'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

/** @type {import('@tanstack/config/typedoc').Package[]} */
const packages = [
  {
    name: 'pacer',
    entryPoints: [resolve(__dirname, '../packages/pacer/src/index.ts')],
    tsconfig: resolve(__dirname, '../packages/pacer/tsconfig.docs.json'),
    outputDir: resolve(__dirname, '../docs/reference'),
  },
  {
    name: 'react-pacer',
    entryPoints: [resolve(__dirname, '../packages/react-pacer/src/index.ts')],
    tsconfig: resolve(__dirname, '../packages/react-pacer/tsconfig.docs.json'),
    outputDir: resolve(__dirname, '../docs/framework/react/reference'),
    exclude: ['packages/pacer/**/*'],
  },
  {
    name: 'solid-pacer',
    entryPoints: [resolve(__dirname, '../packages/solid-pacer/src/index.ts')],
    tsconfig: resolve(__dirname, '../packages/solid-pacer/tsconfig.docs.json'),
    outputDir: resolve(__dirname, '../docs/framework/solid/reference'),
    exclude: ['packages/pacer/**/*'],
  },
]

await generateReferenceDocs({ packages })

// Find all markdown files matching the pattern
const markdownFiles = [
  ...(await fg('docs/reference/**/*.md')),
  ...(await fg('docs/framework/*/reference/**/*.md')),
]

console.log(`Found ${markdownFiles.length} markdown files to process\n`)

// Process each markdown file
markdownFiles.forEach((file) => {
  const content = readFileSync(file, 'utf-8')
  let updatedContent = content
  updatedContent = updatedContent.replaceAll(/\]\(\.\.\//gm, '](../../')
  // updatedContent = content.replaceAll(/\]\(\.\//gm, '](../')
  updatedContent = updatedContent.replaceAll(
    /\]\((?!https?:\/\/|\/\/|\/|\.\/|\.\.\/|#)([^)]+)\)/gm,
    (match, p1) => `](../${p1})`,
  )

  // Write the updated content back to the file
  if (updatedContent !== content) {
    writeFileSync(file, updatedContent, 'utf-8')
    console.log(`Processed file: ${file}`)
  }
})

console.log('\nâœ… All markdown files have been processed!')

process.exit(0)</doc><doc title="Quick Start" desc="docs page.">---
title: Quick Start
id: quick-start
---

TanStack Pacer is, first and foremost, a framework-agnostic utility library for rate limiting, throttling, debouncing, and queuing.

It can be used with any of our framework adapters, but can also be used in vanilla JavaScript or TypeScript.</doc><doc title="Async Batching" desc="docs page.">---
title: Async Batching Guide
id: async-batching
---

All core concepts from the [Batching Guide](../batching.md) apply to async batching as well.

## When to Use Async Batching

While the synchronous batcher works well for many use cases, async batching provides additional capabilities that are particularly useful when:

- You need to capture and use the return value from batch executions
- Your batch processing involves asynchronous operations (API calls, database operations, file I/O)
- You require advanced error handling with configurable error behavior
- You want to track success/error statistics separately
- You need to monitor when batches are actively executing

## Async Batching in TanStack Pacer

TanStack Pacer provides async batching through the `AsyncBatcher` class and the `asyncBatch` function. Unlike the synchronous version, the async batcher handles Promises and provides robust error handling capabilities.

### Basic Usage with `asyncBatch`

The `asyncBatch` function provides a simple way to create an async batching function:

```ts
import { asyncBatch } from '@tanstack/pacer'

const processAsyncBatch = asyncBatch<number>(
  async (items) => {
    // Process the batch asynchronously
    const results = await Promise.all(
      items.map(item => processApiCall(item))
    )
    return results
  },
  {
    maxSize: 3,
    wait: 2000,
    onSuccess: (results, batch, batcher) => {
      console.log('Batch completed successfully:', results)
      console.log('Processed batch:', batch)
      console.log('Total successes:', batcher.store.state.successCount)
    },
    onError: (error, batch, batcher) => {
      console.error('Batch failed:', error)
      console.log('Failed batch:', batch)
      console.log('Total errors:', batcher.store.state.errorCount)
    }
  }
)

// Add items to be batched
processAsyncBatch(1)
processAsyncBatch(2)
processAsyncBatch(3) // Triggers batch processing
```

> **Note:** When using React, prefer `useAsyncBatchedCallback` hook over the `asyncBatch` function for better integration with React's lifecycle and automatic cleanup.

### Advanced Usage with `AsyncBatcher` Class

For more control over async batch behavior, use the `AsyncBatcher` class directly:

```ts
import { AsyncBatcher } from '@tanstack/pacer'

const batcher = new AsyncBatcher<number>(
  async (items) => {
    // Process the batch asynchronously
    const results = await Promise.all(
      items.map(item => processApiCall(item))
    )
    return results
  },
  {
    maxSize: 5,
    wait: 3000,
    onSuccess: (results, batch, batcher) => {
      console.log('Batch succeeded:', results)
      console.log('Processed batch:', batch)
    },
    onError: (error, batch, batcher) => {
      console.error('Batch failed:', error)
      console.log('Failed batch:', batch)
    }
  }
)

// Access current state via TanStack Store
console.log(batcher.store.state.successCount) // Number of successful batch executions
console.log(batcher.store.state.errorCount) // Number of failed batch executions
console.log(batcher.store.state.isExecuting) // Whether a batch is currently executing
console.log(batcher.store.state.lastResult) // Result from most recent batch

// Add items to the batch
batcher.addItem(1)
batcher.addItem(2)

// Control batch execution
batcher.stop()  // Stop processing
batcher.start() // Resume processing
```

## Key Differences from Synchronous Batching

### 1. Return Value Handling

Unlike the synchronous batcher which returns void, the async version allows you to capture and use the return value from your batch function:

```ts
const batcher = new AsyncBatcher<string>(
  async (items) => {
    const results = await processBatch(items)
    return results
  },
  {
    maxSize: 5,
    onSuccess: (results, batch, batcher) => {
      // Handle the returned results
      console.log('Batch results:', results)
      console.log('Processed batch:', batch)
    }
  }
)
```

### 2. Error Handling

The async batcher provides comprehensive error handling capabilities:

```ts
const batcher = new AsyncBatcher<number>(
  async (items) => {
    // This might throw an error
    const results = await riskyBatchOperation(items)
    return results
  },
  {
    maxSize: 3,
    onError: (error, batch, batcher) => {
      // Handle batch errors
      console.error('Batch processing failed:', error)
      console.log('Items that failed:', batch)
      console.log('Total error count:', batcher.store.state.errorCount)
    },
    throwOnError: false, // Don't throw errors, just handle them
    onSuccess: (results, batch, batcher) => {
      console.log('Batch succeeded:', results)
      console.log('Processed batch:', batch)
      console.log('Total success count:', batcher.store.state.successCount)
    },
    onSettled: (batch, batcher) => {
      // Called after every batch (success or failure)
      console.log('Batch settled:', batch)
      console.log('Total batches:', batcher.store.state.settleCount)
    }
  }
)
```

### 3. Execution State Tracking

The async batcher tracks when batches are actively executing:

```ts
const batcher = new AsyncBatcher<number>(
  async (items) => {
    console.log('Starting batch execution...')
    const results = await longRunningBatchOperation(items)
    console.log('Batch execution completed')
    return results
  },
  {
    maxSize: 5,
    onItemsChange: (batcher) => {
      console.log('Is executing:', batcher.store.state.isExecuting)
      console.log('Items in queue:', batcher.store.state.size)
    }
  }
)
```

### 4. Different Callbacks

The `AsyncBatcher` supports these async-specific callbacks:

- `onSuccess`: Called after each successful batch execution, providing the result, the batch of items processed, and batcher instance
- `onError`: Called when a batch execution fails, providing the error, the batch of items that failed, and batcher instance
- `onSettled`: Called after each batch execution (success or failure), providing the batch of items processed and batcher instance
- `onExecute`: Called after each batch execution, providing the batch of items processed and batcher instance (same as synchronous batcher)
- `onItemsChange`: Called when items are added or the batch is processed

## Advanced Features: Retry and Abort Support

The async batcher includes built-in retry and abort capabilities through integration with `AsyncRetryer`. These features help handle transient failures and provide control over in-flight operations.

### Retry Support

Configure automatic retries for failed batch executions using the `asyncRetryerOptions`:

```ts
const batcher = new AsyncBatcher<number>(
  async (items) => {
    // This might fail due to network issues
    const results = await apiCall(items)
    return results
  },
  {
    maxSize: 5,
    asyncRetryerOptions: {
      maxAttempts: 3,
      backoff: 'exponential',
      baseWait: 1000,
      maxWait: 10000,
      jitter: 0.3
    }
  }
)
```

For complete documentation on retry strategies, backoff algorithms, jitter, and advanced retry patterns, see the [Async Retrying Guide](./async-retrying.md).

### Abort Support

Cancel in-flight batch executions using the abort functionality:

```ts
const batcher = new AsyncBatcher<number>(
  async (items) => {
    // Access the abort signal for this execution
    const signal = batcher.getAbortSignal()
    if (signal) {
      const response = await fetch('/api/batch', {
        method: 'POST',
        body: JSON.stringify(items),
        signal // Pass signal to fetch for cancellation support
      })
      return response.json()
    }
  },
  { maxSize: 10 }
)

// Add items
batcher.addItem(1)
batcher.addItem(2)

// Later, abort any in-flight batch executions
batcher.abort()
```

The abort functionality:
- Cancels all ongoing batch executions using AbortController
- Does NOT cancel pending batches that haven't started yet (use `cancel()` for that)
- Does NOT clear items from the batcher
- Can be used alongside retry support

For more details on abort patterns and integration with fetch/axios, see the [Async Retrying Guide](./async-retrying.md).

### Sharing Options Between Instances

Use `asyncBatcherOptions` to share common options between different `AsyncBatcher` instances:

```ts
import { asyncBatcherOptions, AsyncBatcher } from '@tanstack/pacer'

const sharedOptions = asyncBatcherOptions({
  maxSize: 5,
  wait: 2000,
  onSuccess: (results, batch, batcher) => console.log('Success')
})

const batcher1 = new AsyncBatcher(fn1, { ...sharedOptions, key: 'batcher1' })
const batcher2 = new AsyncBatcher(fn2, { ...sharedOptions, maxSize: 10 })
```

## Error Handling Options

The async batcher provides flexible error handling through the `throwOnError` option:

```ts
const batcher = new AsyncBatcher<number>(
  async (items) => {
    // This might throw an error
    throw new Error('Batch processing failed')
  },
  {
    maxSize: 3,
    onError: (error, batch, batcher) => {
      console.error('Handling error:', error)
    },
    throwOnError: true, // Will throw errors even with onError handler
    // throwOnError: false, // Will swallow errors (default if onError is provided)
    // throwOnError: undefined, // Uses default behavior based on onError presence
  }
)
```

- **Default behavior**: `throwOnError` is `true` if no `onError` handler is provided, `false` if an `onError` handler is provided
- **With `onError` handler**: The handler is called first, then the error is thrown if `throwOnError` is `true`
- **Error state**: Failed items are tracked in `failedItems` array and can be accessed via `peekFailedItems()`. The `onError` callback receives the batch of items that failed, not the accumulated failed items.

## Dynamic Options

Like the synchronous batcher, the async batcher supports dynamic options:

```ts
const batcher = new AsyncBatcher<number>(
  async (items) => {
    return await processBatch(items)
  },
  {
    // Dynamic batch size based on success rate
    maxSize: (batcher) => {
      const successRate = batcher.store.state.successCount / Math.max(1, batcher.store.state.settleCount)
      return successRate > 0.8 ? 10 : 5 // Larger batches if success rate is high
    },
    // Dynamic wait time based on error count
    wait: (batcher) => {
      return batcher.store.state.errorCount > 5 ? 5000 : 2000 // Wait longer if errors are frequent
    }
  }
)
```

### Flushing Pending Batches

The async batcher supports flushing pending batches to trigger processing immediately:

```ts
const batcher = new AsyncBatcher(asyncBatchFn, { maxSize: 10, wait: 5000 })

batcher.addItem('item1')
batcher.addItem('item2')
console.log(batcher.store.state.isPending) // true

// Flush immediately instead of waiting
const result = await batcher.flush()
console.log('Flush result:', result)
console.log(batcher.store.state.isEmpty) // true (batch was processed)
```

## State Management

The `AsyncBatcher` class uses TanStack Store for reactive state management, providing real-time access to batch execution state, error tracking, and processing statistics. All state is stored in a TanStack Store and can be accessed via `asyncBatcher.store.state`, although, if you are using a framework adapter like React or Solid, you will not want to read the state from here. Instead, you will read the state from `asyncBatcher.state` along with providing a selector callback as the 3rd argument to the `useAsyncBatcher` hook to opt-in to state tracking as shown below.

### State Selector (Framework Adapters)

Framework adapters support a `selector` argument that allows you to specify which state changes will trigger re-renders. This optimizes performance by preventing unnecessary re-renders when irrelevant state changes occur.

**By default, `asyncBatcher.state` is empty (`{}`) as the selector is empty by default.** This is where reactive state from a TanStack Store `useStore` gets stored. You must opt-in to state tracking by providing a selector function.

```ts
// Default behavior - no reactive state subscriptions
const batcher = useAsyncBatcher(asyncBatchFn, { maxSize: 5, wait: 1000 })
console.log(batcher.state) // {}

// Opt-in to re-render when isExecuting changes
const batcher = useAsyncBatcher(
  asyncBatchFn, 
  { maxSize: 5, wait: 1000 },
  (state) => ({ isExecuting: state.isExecuting })
)
console.log(batcher.state.isExecuting) // Reactive value

// Multiple state properties
const batcher = useAsyncBatcher(
  asyncBatchFn,
  { maxSize: 5, wait: 1000 },
  (state) => ({
    isExecuting: state.isExecuting,
    successCount: state.successCount,
    errorCount: state.errorCount
  })
)
```

### Initial State

You can provide initial state values when creating an async batcher. This is commonly used to restore state from persistent storage:

```ts
// Load initial state from localStorage
const savedState = localStorage.getItem('async-batcher-state')
const initialState = savedState ? JSON.parse(savedState) : {}

const batcher = new AsyncBatcher(asyncBatchFn, {
  maxSize: 5,
  wait: 1000,
  initialState
})
```

### Subscribing to State Changes

The store is reactive and supports subscriptions:

```ts
const batcher = new AsyncBatcher(asyncBatchFn, { maxSize: 5, wait: 1000 })

// Subscribe to state changes
const unsubscribe = batcher.store.subscribe((state) => {
  // do something with the state like persist it to localStorage
})

// Unsubscribe when done
unsubscribe()
```

> **Note:** This is unnecessary when using a framework adapter because the underlying `useStore` hook already does this. You can also import and use `useStore` from TanStack Store to turn `batcher.store.state` into reactive state with a custom selector wherever you want if necessary.

```ts
const batcher = useAsyncBatcher(asyncBatchFn, { maxSize: 5, wait: 1000 })

// you could manually use the `useStore` hook to subscribe to state changes in whatever scope you want
const state = useStore(batcher.store, (state) => ({
  successCount: state.successCount,
}))

console.log(state)
```

### Available State Properties

The `AsyncBatcherState` includes:

- `errorCount`: Number of batch executions that have resulted in errors
- `failedItems`: Array of items that failed during batch processing
- `isEmpty`: Whether the batcher has no items to process (items array is empty)
- `isExecuting`: Whether a batch is currently being processed asynchronously
- `isPending`: Whether the batcher is waiting for the timeout to trigger batch processing
- `items`: Array of items currently queued for batch processing
- `lastResult`: The result from the most recent batch execution
- `settleCount`: Number of batch executions that have completed (either successfully or with errors)
- `size`: Number of items currently in the batch queue
- `status`: Current processing status ('idle' | 'pending' | 'executing' | 'populated')
- `successCount`: Number of batch executions that have completed successfully
- `totalItemsFailed`: Total number of items that have failed processing across all batches
- `totalItemsProcessed`: Total number of items that have been processed across all batches

### Monitoring Failed Items

The async batcher tracks items that failed during batch processing:

```ts
const batcher = new AsyncBatcher<number>(
  async (items) => {
    // This might fail for some items
    if (items.some(item => item < 0)) {
      throw new Error('Negative numbers not allowed')
    }
    return await processBatch(items)
  },
  {
    maxSize: 3,
    onError: (error, batch, batcher) => {
      console.log('Failed batch:', batch)
      console.log('All failed items:', batcher.peekFailedItems())
    }
  }
)
```

## Framework Adapters

Each framework adapter provides hooks that build on top of the core async batching functionality to integrate with the framework's state management system. Hooks like `useAsyncBatcher` or similar are available for each framework.

---

For core batching concepts and synchronous batching, see the [Batching Guide](../batching.md).</doc><doc title="Async Debouncing" desc="docs page.">---
title: Async Debouncing Guide
id: async-debouncing
---

All core concepts from the [Debouncing Guide](../debouncing.md) apply to async debouncing as well. 

## When to Use Async Debouncing

You can usually just use the normal synchronous debouncer and it will work with async functions, but for advanced use cases, such as wanting to use the return value of a debounced function (instead of just calling a setState side effect), or putting your error handling logic in the debouncer, you can use the async debouncer.

## Async Debouncing in TanStack Pacer

TanStack Pacer provides async debouncing through the `AsyncDebouncer` class and the `asyncDebounce` function.

### Basic Usage Example

Here's a basic example showing how to use the async debouncer for a search operation:

```ts
const debouncedSearch = asyncDebounce(
  async (searchTerm: string) => {
    const results = await fetchSearchResults(searchTerm)
    return results
  },
  {
    wait: 500,
    onSuccess: (results, args, debouncer) => {
      console.log('Search succeeded:', results)
      console.log('Search arguments:', args)
    },
      onError: (error, args, debouncer) => {
    console.error('Search failed:', error)
    console.log('Failed arguments:', args)
  }
  }
)

// Usage
try {
  const results = await debouncedSearch('query')
  // Handle successful results
} catch (error) {
  // Handle errors if no onError handler was provided
  console.error('Search failed:', error)
}
```

> **Note:** When using React, prefer `useAsyncDebouncedCallback` hook over the `asyncDebounce` function for better integration with React's lifecycle and automatic cleanup.

## Key Differences from Synchronous Debouncing

### 1. Return Value Handling

Unlike the synchronous debouncer which returns void, the async version allows you to capture and use the return value from your debounced function. The `maybeExecute` method returns a Promise that resolves with the function's return value, allowing you to await the result and handle it appropriately.

### 2. Error Handling

The async debouncer provides robust error handling capabilities:
- If your debounced function throws an error and no `onError` handler is provided, the error will be thrown and propagate up to the caller
- If you provide an `onError` handler, errors will be caught and passed to the handler instead of being thrown
- The `throwOnError` option can be used to control error throwing behavior:
  - When true (default if no onError handler), errors will be thrown
  - When false (default if onError handler provided), errors will be swallowed
  - Can be explicitly set to override these defaults
- You can track error counts using `debouncer.store.state.errorCount` and check execution state with `debouncer.store.state.isExecuting`
- The debouncer maintains its state and can continue to be used after an error occurs

### 3. Different Callbacks

The `AsyncDebouncer` supports the following callbacks:
- `onSuccess`: Called after each successful execution, providing the result, the arguments that were executed, and debouncer instance
- `onSettled`: Called after each execution (success or failure), providing the arguments that were executed and debouncer instance
- `onError`: Called if the async function throws an error, providing the error, the arguments that caused the error, and the debouncer instance

Example:

```ts
const asyncDebouncer = new AsyncDebouncer(async (value) => {
  await saveToAPI(value)
}, {
  wait: 500,
  onSuccess: (result, args, debouncer) => {
    // Called after each successful execution
    console.log('Async function executed', debouncer.store.state.successCount)
    console.log('Executed arguments:', args)
  },
  onSettled: (args, debouncer) => {
    // Called after each execution attempt
    console.log('Async function settled', debouncer.store.state.settleCount)
    console.log('Settled arguments:', args)
  },
  onError: (error) => {
    // Called if the async function throws an error
    console.error('Async function failed:', error)
  }
})
```

### 4. Sequential Execution

Since the debouncer's `maybeExecute` method returns a Promise, you can choose to await each execution before starting the next one. This gives you control over the execution order and ensures each call processes the most up-to-date data. This is particularly useful when dealing with operations that depend on the results of previous calls or when maintaining data consistency is critical.

For example, if you're updating a user's profile and then immediately fetching their updated data, you can await the update operation before starting the fetch.

## Advanced Features: Retry and Abort Support

The async debouncer includes built-in retry and abort capabilities through integration with `AsyncRetryer`. These features help handle transient failures and provide control over in-flight operations.

### Retry Support

Configure automatic retries for failed debounced function executions using the `asyncRetryerOptions`:

```ts
const debouncedSave = asyncDebounce(
  async (data: string) => {
    // This might fail due to network issues
    await api.save(data)
  },
  {
    wait: 500,
    asyncRetryerOptions: {
      maxAttempts: 3,
      backoff: 'exponential',
      baseWait: 1000,
      maxWait: 10000,
      jitter: 0.3
    }
  }
)
```

For complete documentation on retry strategies, backoff algorithms, jitter, and advanced retry patterns, see the [Async Retrying Guide](./async-retrying.md).

### Abort Support

Cancel in-flight debounced executions using the abort functionality:

```ts
const debouncer = new AsyncDebouncer(
  async (searchTerm: string) => {
    // Access the abort signal for this execution
    const signal = debouncer.getAbortSignal()
    if (signal) {
      const response = await fetch(`/api/search?q=${searchTerm}`, { signal })
      return response.json()
    }
  },
  { wait: 300 }
)

// Start a search
debouncer.maybeExecute('query')

// Later, abort any in-flight execution
debouncer.abort()
```

The abort functionality:
- Cancels all ongoing debounced executions using AbortController
- Does NOT cancel pending executions that haven't started yet (use `cancel()` for that)
- Can be used alongside retry support

For more details on abort patterns and integration with fetch/axios, see the [Async Retrying Guide](./async-retrying.md).

### Sharing Options Between Instances

Use `asyncDebouncerOptions` to share common options between different `AsyncDebouncer` instances:

```ts
import { asyncDebouncerOptions, AsyncDebouncer } from '@tanstack/pacer'

const sharedOptions = asyncDebouncerOptions({
  wait: 500,
  leading: false,
  trailing: true,
  onSuccess: (result, args, debouncer) => console.log('Success')
})

const debouncer1 = new AsyncDebouncer(fn1, { ...sharedOptions, key: 'debouncer1' })
const debouncer2 = new AsyncDebouncer(fn2, { ...sharedOptions, onError: (error) => console.error('Error') })
```

## Dynamic Options and Enabling/Disabling

Just like the synchronous debouncer, the async debouncer supports dynamic options for `wait` and `enabled`, which can be functions that receive the debouncer instance. This allows for sophisticated, runtime-adaptive debouncing behavior.

### Flushing Pending Executions

The async debouncer supports flushing pending executions to trigger them immediately:

```ts
const asyncDebouncer = new AsyncDebouncer(asyncFn, { wait: 1000 })

asyncDebouncer.maybeExecute('some-arg')
console.log(asyncDebouncer.store.state.isPending) // true

// Flush immediately instead of waiting
asyncDebouncer.flush()
console.log(asyncDebouncer.store.state.isPending) // false
```

## State Management

The `AsyncDebouncer` class uses TanStack Store for reactive state management, providing real-time access to execution state, error tracking, and execution statistics. All state is stored in a TanStack Store and can be accessed via `asyncDebouncer.store.state`, although, if you are using a framework adapter like React or Solid, you will not want to read the state from here. Instead, you will read the state from `asyncDebouncer.state` along with providing a selector callback as the 3rd argument to the `useAsyncDebouncer` hook to opt-in to state tracking as shown below.

### State Selector (Framework Adapters)

Framework adapters support a `selector` argument that allows you to specify which state changes will trigger re-renders. This optimizes performance by preventing unnecessary re-renders when irrelevant state changes occur.

**By default, `debouncer.state` is empty (`{}`) as the selector is empty by default.** This is where reactive state from a TanStack Store `useStore` gets stored. You must opt-in to state tracking by providing a selector function.

```ts
// Default behavior - no reactive state subscriptions
const asyncDebouncer = useAsyncDebouncer(asyncFn, { wait: 500 })
console.log(asyncDebouncer.state) // {}

// Opt-in to re-render when isExecuting changes
const asyncDebouncer = useAsyncDebouncer(
  asyncFn, 
  { wait: 500 },
  (state) => ({ isExecuting: state.isExecuting })
)
console.log(asyncDebouncer.state.isExecuting) // Reactive value

// Multiple state properties
const asyncDebouncer = useAsyncDebouncer(
  asyncFn,
  { wait: 500 },
  (state) => ({
    isExecuting: state.isExecuting,
    successCount: state.successCount,
    errorCount: state.errorCount
  })
)
```

### Initial State

You can provide initial state values when creating an async debouncer. This is commonly used to restore state from persistent storage:

```ts
// Load initial state from localStorage
const savedState = localStorage.getItem('async-debouncer-state')
const initialState = savedState ? JSON.parse(savedState) : {}

const asyncDebouncer = new AsyncDebouncer(asyncFn, {
  wait: 500,
  initialState
})
```

### Subscribing to State Changes

The store is reactive and supports subscriptions:

```ts
const asyncDebouncer = new AsyncDebouncer(asyncFn, { wait: 500 })

// Subscribe to state changes
const unsubscribe = asyncDebouncer.store.subscribe((state) => {
  // do something with the state like persist it to localStorage
})

// Unsubscribe when done
unsubscribe()
```

> **Note:** This is unnecessary when using a framework adapter because the underlying `useStore` hook already does this. You can also import and use `useStore` from TanStack Store to turn `debouncer.store.state` into reactive state with a custom selector wherever you want if necessary.

### Available State Properties

The `AsyncDebouncerState` includes:

- `canLeadingExecute`: Whether the debouncer can execute on the leading edge of the timeout
- `errorCount`: Number of function executions that have resulted in errors
- `isExecuting`: Whether the debounced function is currently executing asynchronously
- `isPending`: Whether the debouncer is waiting for the timeout to trigger execution
- `lastArgs`: The arguments from the most recent call to `maybeExecute`
- `lastResult`: The result from the most recent successful function execution
- `maybeExecuteCount`: Number of times `maybeExecute` has been called
- `settleCount`: Number of function executions that have completed (either successfully or with errors)
- `status`: Current execution status ('disabled' | 'idle' | 'pending' | 'executing' | 'settled')
- `successCount`: Number of function executions that have completed successfully

## Framework Adapters

Each framework adapter provides hooks that build on top of the core async debouncing functionality to integrate with the framework's state management system. Hooks like `createAsyncDebouncer`, `useAsyncDebouncedCallback`, or similar are available for each framework.

---

For core debouncing concepts and synchronous debouncing, see the [Debouncing Guide](../debouncing.md).</doc></docs><tutorials><doc title="README" desc="install &amp; quickstart."># AsyncBatch Example

This example demonstrates how to use the `asyncBatch` function from `@tanstack/react-pacer` wrapped in a `useCallback` hook for optimal performance.

The example combines features from both the `batch` and `useAsyncBatcher` examples:

- Uses `asyncBatch` function (functional API) like in the sync batcher examples
- Wrapped in `useCallback` for performance optimization
- Demonstrates async processing with error handling
- Shows manual state management for batch tracking

## Key Features

- **Async Processing**: Processes items asynchronously with simulated delays
- **Batch Control**: Batches up to 5 items or processes after 3 seconds
- **Urgent Processing**: Items marked as "urgent" trigger immediate processing
- **Error Handling**: Graceful error handling with configurable failure simulation
- **Performance**: Uses `useCallback` to prevent unnecessary re-renders
- **Manual State Management**: Tracks processing state without reactive hooks

## To run this example:

- `npm install`
- `npm run dev`</doc><doc title="README" desc="install &amp; quickstart."># Example

To run this example:

- `npm install`
- `npm run dev`</doc><doc title="README" desc="install &amp; quickstart."># Example

To run this example:

- `npm install`
- `npm run dev`</doc><doc title="README" desc="install &amp; quickstart."># AsyncBatch Example

This example demonstrates how to use the `asyncBatch` function from `@tanstack/react-pacer` wrapped in a `useCallback` hook for optimal performance.

The example combines features from both the `batch` and `useAsyncBatcher` examples:

- Uses `asyncBatch` function (functional API) like in the sync batcher examples
- Wrapped in `useCallback` for performance optimization
- Demonstrates async processing with error handling
- Shows manual state management for batch tracking

## Key Features

- **Async Processing**: Processes items asynchronously with simulated delays
- **Batch Control**: Batches up to 5 items or processes after 3 seconds
- **Urgent Processing**: Items marked as "urgent" trigger immediate processing
- **Error Handling**: Graceful error handling with configurable failure simulation
- **Performance**: Uses `useCallback` to prevent unnecessary re-renders
- **Manual State Management**: Tracks processing state without reactive hooks

## To run this example:

- `npm install`
- `npm run dev`</doc><doc title="README" desc="install &amp; quickstart."># Example

To run this example:

- `npm install`
- `npm run dev`</doc><doc title="README" desc="install &amp; quickstart."># Example

To run this example:

- `npm install`
- `npm run dev`</doc><doc title="README" desc="install &amp; quickstart."># Example

To run this example:

- `npm install`
- `npm run dev`</doc><doc title="README" desc="install &amp; quickstart."># Example

To run this example:

- `npm install`
- `npm run dev`</doc><doc title="README" desc="install &amp; quickstart."># Example

To run this example:

- `npm install`
- `npm run dev`</doc><doc title="README" desc="install &amp; quickstart."># Example

To run this example:

- `npm install`
- `npm run dev`</doc></tutorials><packages><doc title="Eslint.Config" desc="docs page.">// @ts-check

import rootConfig from '../../eslint.config.js'

export default [
  ...rootConfig,
  {
    rules: {},
  },
]</doc><doc title="Eslint.Config" desc="docs page.">// @ts-check

import rootConfig from '../../eslint.config.js'

export default [
  ...rootConfig,
  {
    rules: {},
  },
]</doc><doc title="Eslint.Config" desc="docs page.">// @ts-check

import pluginReact from '@eslint-react/eslint-plugin'
import pluginReactCompiler from 'eslint-plugin-react-compiler'
import pluginReactHooks from 'eslint-plugin-react-hooks'
import rootConfig from '../../eslint.config.js'

export default [
  ...rootConfig,
  {
    files: ['**/*.{ts,tsx}'],
    ...pluginReact.configs.recommended,
  },
  {
    plugins: {
      'react-hooks': pluginReactHooks,
      'react-compiler': pluginReactCompiler,
    },
    rules: {
      '@eslint-react/dom/no-missing-button-type': 'off',
      'react-compiler/react-compiler': 'error',
      'react-hooks/exhaustive-deps': 'error',
      'react-hooks/rules-of-hooks': 'error',
    },
  },
  {
    files: ['**/__tests__/**'],
    rules: {
      // 'react-compiler/react-compiler': 'off',
    },
  },
]</doc><doc title="Eslint.Config" desc="docs page.">// @ts-check

import pluginReact from '@eslint-react/eslint-plugin'
import pluginReactCompiler from 'eslint-plugin-react-compiler'
import pluginReactHooks from 'eslint-plugin-react-hooks'
import rootConfig from '../../eslint.config.js'

export default [
  ...rootConfig,
  {
    files: ['**/*.{ts,tsx}'],
    ...pluginReact.configs.recommended,
  },
  {
    plugins: {
      'react-hooks': pluginReactHooks,
      'react-compiler': pluginReactCompiler,
    },
    rules: {
      '@eslint-react/dom/no-missing-button-type': 'off',
      'react-compiler/react-compiler': 'error',
      'react-hooks/exhaustive-deps': 'error',
      'react-hooks/rules-of-hooks': 'error',
    },
  },
  {
    files: ['**/__tests__/**'],
    rules: {
      // 'react-compiler/react-compiler': 'off',
    },
  },
]</doc><doc title="Eslint.Config" desc="docs page.">// @ts-check

import rootConfig from '../../eslint.config.js'

export default [
  ...rootConfig,
  {
    rules: {},
  },
]</doc><doc title="Eslint.Config" desc="docs page.">// @ts-check

import rootConfig from '../../eslint.config.js'

export default [
  ...rootConfig,
  {
    files: ['**/*.{ts,tsx}'],
  },
  {
    plugins: {},
    rules: {},
  },
  {
    files: ['**/__tests__/**'],
    rules: {},
  },
]</doc><doc title="Vite.Config" desc="docs page.">import { defineConfig, mergeConfig } from 'vitest/config'
import { tanstackViteConfig } from '@tanstack/config/vite'
import solid from 'vite-plugin-solid'
import packageJson from './package.json'

const config = defineConfig({
  plugins: [solid()],
  test: {
    name: packageJson.name,
    dir: './',
    watch: false,
    environment: 'jsdom',
    setupFiles: ['./tests/test-setup.ts'],
    globals: true,
  },
})

export default mergeConfig(
  config,
  tanstackViteConfig({
    entry: ['./src/index.ts', './src/production.ts'],
    srcDir: './src',
    cjs: false,
  }),
)</doc><doc title="Vite.Config" desc="docs page.">import { defineConfig, mergeConfig } from 'vitest/config'
import { tanstackViteConfig } from '@tanstack/config/vite'
import packageJson from './package.json'

const config = defineConfig({
  test: {
    name: packageJson.name,
    dir: './',
    watch: false,
    environment: 'jsdom',
    setupFiles: ['./tests/test-setup.ts'],
    globals: true,
  },
})

export default mergeConfig(
  config,
  tanstackViteConfig({
    entry: ['./src/index.ts'],
    srcDir: './src',
  }),
)</doc><doc title="Vite.Config" desc="docs page.">import { defineConfig, mergeConfig } from 'vitest/config'
import { tanstackViteConfig } from '@tanstack/config/vite'
import react from '@vitejs/plugin-react'
import packageJson from './package.json'

const config = defineConfig({
  plugins: [react()],
  test: {
    name: packageJson.name,
    dir: './',
    watch: false,
    environment: 'jsdom',
    setupFiles: ['./tests/test-setup.ts'],
    globals: true,
  },
})

export default mergeConfig(
  config,
  tanstackViteConfig({
    entry: ['./src/index.ts', './src/production.ts'],
    srcDir: './src',
    cjs: false,
  }),
)</doc><doc title="Vite.Config" desc="docs page.">import { defineConfig, mergeConfig } from 'vitest/config'
import { tanstackViteConfig } from '@tanstack/config/vite'
import react from '@vitejs/plugin-react'
import packageJson from './package.json'

const config = defineConfig({
  plugins: [react()],
  test: {
    name: packageJson.name,
    dir: './tests',
    watch: false,
    environment: 'jsdom',
    // setupFiles: ['./tests/test-setup.ts'],
    globals: true,
  },
})

export default mergeConfig(
  config,
  tanstackViteConfig({
    entry: [
      './src/async-batcher/index.ts',
      './src/async-debouncer/index.ts',
      './src/async-queuer/index.ts',
      './src/async-rate-limiter/index.ts',
      './src/async-retryer/index.ts',
      './src/async-throttler/index.ts',
      './src/batcher/index.ts',
      './src/debouncer/index.ts',
      './src/index.ts',
      './src/provider/index.ts',
      './src/queuer/index.ts',
      './src/rate-limiter/index.ts',
      './src/throttler/index.ts',
      './src/types/index.ts',
      './src/utils/index.ts',
    ],
    srcDir: './src',
  }),
)</doc></packages></project>
