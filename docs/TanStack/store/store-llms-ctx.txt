<project title="Store" summary="TanStack Store is a lightweight, immutable, and reactive state management library designed to provide fine-grained updates for high-performance applications. It serves as a foundational tool in the TanStack ecosystem, offering flexible primitives for custom state logic and seamless integration across major frameworks including React, Solid, Vue, Angular, and Svelte. Its goal is to empower developers to manage state efficiently while maintaining type safety and enabling scalable, maintainable applications.">**Remember:**
- immutable state
- reactive updates
- fine-grained state management
- framework-agnostic
- derived state
- effect hooks<docs><doc title="Installation" desc="install &amp; quickstart.">---
title: Installation
id: installation
---

You can install TanStack Store with any [NPM](https://npmjs.com) package manager.

## React

```sh
npm install @tanstack/react-store
```

TanStack Store is compatible with React v16.8+ and is currently only compatible with ReactDOM only. If you would like to contribute to the React Native adapter, please reach out to us on [Discord](https://tlinz.com/discord).

## Vue

```sh
npm install @tanstack/vue-store
```

TanStack Store is compatible with Vue 2 and 3.

## Angular

```sh
npm install @tanstack/angular-store
```

TanStack Store is compatible with Angular 19+

## SolidJS

```sh
npm install @tanstack/solid-store
```

TanStack Store is compatible with Solid and SolidStart.

## Svelte

```sh
npm install @tanstack/svelte-store
```

TanStack Store is compatible with Svelte 5.</doc><doc title="Overview" desc="install &amp; quickstart.">---
title: Overview
id: overview
---

TanStack Store is a framework agnostic data store that ships with framework specific adapters for major frameworks like React, Solid, Vue, Angular, and Svelte.

TanStack Store is primarily used for state management internally for most framework agnostic TanStack libraries. It can also be used as a standalone library for any framework or application.</doc><doc title="Reference" desc="API reference.">---
id: "@tanstack/store"
title: "@tanstack/store"
---


# @tanstack/store

## Classes

- [Derived](../classes/derived.md)
- [Effect](../classes/effect.md)
- [Store](../classes/store.md)

## Interfaces

- [DerivedFnProps](../interfaces/derivedfnprops.md)
- [DerivedOptions](../interfaces/derivedoptions.md)
- [StoreOptions](../interfaces/storeoptions.md)

## Type Aliases

- [UnwrapDerivedOrStore](../type-aliases/unwrapderivedorstore.md)
- [Updater](../type-aliases/updater.md)

## Variables

- [\_\_depsThatHaveWrittenThisTick](../variables/depsthathavewrittenthistick.md)
- [\_\_derivedToStore](../variables/derivedtostore.md)
- [\_\_storeToDerived](../variables/storetoderived.md)

## Functions

- [batch](../functions/batch.md)
- [isUpdaterFunction](../functions/isupdaterfunction.md)</doc><doc title="Reference" desc="API reference.">---
id: "@tanstack/angular-store"
title: "@tanstack/angular-store"
---


# @tanstack/angular-store

## Functions

- [injectStore](../functions/injectstore.md)</doc><doc title="Reference" desc="API reference.">---
id: "@tanstack/react-store"
title: "@tanstack/react-store"
---


# @tanstack/react-store

## Functions

- [shallow](../functions/shallow.md)
- [useStore](../functions/usestore.md)</doc><doc title="Reference" desc="API reference.">---
id: "@tanstack/solid-store"
title: "@tanstack/solid-store"
---


# @tanstack/solid-store

## Functions

- [shallow](../functions/shallow.md)
- [useStore](../functions/usestore.md)</doc><doc title="Reference" desc="API reference.">---
id: "@tanstack/svelte-store"
title: "@tanstack/svelte-store"
---


# @tanstack/svelte-store

## Functions

- [shallow](../functions/shallow.md)
- [useStore](../functions/usestore.md)</doc><doc title="Reference" desc="API reference.">---
id: "@tanstack/vue-store"
title: "@tanstack/vue-store"
---


# @tanstack/vue-store

## Functions

- [shallow](../functions/shallow.md)
- [useStore](../functions/usestore.md)</doc><doc title="Generatedocs" desc="docs page.">import { resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { readFileSync, writeFileSync } from 'node:fs'
import { generateReferenceDocs } from '@tanstack/config/typedoc'
import { glob } from 'tinyglobby'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

await generateReferenceDocs({
  packages: [
    {
      name: 'store',
      entryPoints: [resolve(__dirname, '../packages/store/src/index.ts')],
      tsconfig: resolve(__dirname, '../packages/store/tsconfig.docs.json'),
      outputDir: resolve(__dirname, '../docs/reference'),
    },
    {
      name: 'angular-store',
      entryPoints: [
        resolve(__dirname, '../packages/angular-store/src/index.ts'),
      ],
      tsconfig: resolve(
        __dirname,
        '../packages/angular-store/tsconfig.docs.json',
      ),
      outputDir: resolve(__dirname, '../docs/framework/angular/reference'),
      exclude: ['packages/store/**/*'],
    },
    {
      name: 'react-store',
      entryPoints: [resolve(__dirname, '../packages/react-store/src/index.ts')],
      tsconfig: resolve(
        __dirname,
        '../packages/react-store/tsconfig.docs.json',
      ),
      outputDir: resolve(__dirname, '../docs/framework/react/reference'),
      exclude: ['packages/store/**/*'],
    },
    {
      name: 'solid-store',
      entryPoints: [
        resolve(__dirname, '../packages/solid-store/src/index.tsx'),
      ],
      tsconfig: resolve(
        __dirname,
        '../packages/solid-store/tsconfig.docs.json',
      ),
      outputDir: resolve(__dirname, '../docs/framework/solid/reference'),
      exclude: ['packages/store/**/*'],
    },
    {
      name: 'svelte-store',
      entryPoints: [
        resolve(__dirname, '../packages/svelte-store/src/index.ts'),
      ],
      tsconfig: resolve(
        __dirname,
        '../packages/svelte-store/tsconfig.docs.json',
      ),
      outputDir: resolve(__dirname, '../docs/framework/svelte/reference'),
      exclude: ['packages/store/**/*'],
    },
    {
      name: 'vue-store',
      entryPoints: [resolve(__dirname, '../packages/vue-store/src/index.ts')],
      tsconfig: resolve(__dirname, '../packages/vue-store/tsconfig.docs.json'),
      outputDir: resolve(__dirname, '../docs/framework/vue/reference'),
      exclude: ['packages/store/**/*'],
    },
  ],
})

// Find all markdown files matching the pattern
const markdownFiles = [
  ...(await glob('docs/reference/**/*.md')),
  ...(await glob('docs/framework/*/reference/**/*.md')),
]

console.log(`Found ${markdownFiles.length} markdown files to process\n`)

// Process each markdown file
markdownFiles.forEach((file) => {
  const content = readFileSync(file, 'utf-8')
  let updatedContent = content
  updatedContent = updatedContent.replaceAll(/\]\(\.\.\//gm, '](../../')
  // updatedContent = content.replaceAll(/\]\(\.\//gm, '](../')
  updatedContent = updatedContent.replaceAll(
    /\]\((?!https?:\/\/|\/\/|\/|\.\/|\.\.\/|#)([^)]+)\)/gm,
    // @ts-expect-error
    (match, p1) => `](../${p1})`,
  )

  // Write the updated content back to the file
  if (updatedContent !== content) {
    writeFileSync(file, updatedContent, 'utf-8')
    console.log(`Processed file: ${file}`)
  }
})

console.log('\n✅ All markdown files have been processed!')

process.exit(0)</doc><doc title="Quick Start" desc="docs page.">---
title: Quick Start
id: quick-start
---

TanStack Store is, first and foremost, a framework-agnostic signals implementation.

It can be used with any of our framework adapters, but can also be used in vanilla JavaScript or TypeScript. It's currently used to power many of our library's internals.

## Store

You'll start by creating a new store instance, which is a wrapper around your data:

```typescript
import { Store } from '@tanstack/store';

const countStore = new Store(0);

console.log(countStore.state); // 0
countStore.setState(() => 1);
console.log(countStore.state); // 1
```

This `Store` can then be used to track updates to your data:

```typescript
const unsub = countStore.subscribe(() => {
  console.log('The count is now:', countStore.state);
});

// Later, to cleanup
unsub();
```

You can even transform the data before it's updated:

```typescript
const count = new Store(12, {
  updateFn: (prevValue) => (updateValue) => {
    return updateValue(prevValue) + previous;
  }
});

count.setState(() => 12);
// count.state === 24
```

And implement a primitive form of derived state:

```typescript
let double = 0;
const count = new Store(0, {
  onUpdate: () => {
    double = count.state * 2;
  }
})
```

### Batch Updates

You can batch updates to a store by using the `batch` function:

```typescript
import { batch } from '@tanstack/store';

// countStore.subscribers will only trigger once at the end with the final state
batch(() => {
  countStore.setState(() => 1);
  countStore.setState(() => 2);
});
```

## Derived

You can also use the `Derived` class to create derived values that lazily update when their dependencies change:

```typescript
const count = new Store(0);

const double = new Derived({
  fn: () => count.state * 2,
  // Must explicitly list dependencies
  deps: [count]
});

// Must mount the derived value to start listening for updates
const unmount = double.mount();

// Later, to cleanup
unmount();
```

### Previous Derived Value

You can access the previous value of a derived computation by using the `prevVal` argument passed to the `fn` function:

```typescript
const count = new Store(1);

const double = new Derived({
  fn: ({ prevVal }) => {
    return count.state + (prevVal ?? 0);
  },
  deps: [count]
});

double.mount();
double.state; // 1
count.setState(() => 2);
double.state; // 3
```

### Dependency Values

You can access the values of the dependencies of a derived computation by using the `prevDepVals` and `currDepVals` arguments passed to the `fn` function:

```typescript
const count = new Store(1);

const double = new Derived({
  fn: ({ prevDepVals, currDepVals }) => {
    return (prevDepVals[0] ?? 0) + currDepVals[0];
  },
  deps: [count]
});

double.mount();
double.state; // 1
count.setState(() => 2);
double.state; // 3
```

## Effects

You can also use the `Effect` class to manage side effects across multiple stores and derived values:

```typescript
const effect = new Effect({
  fn: () => {
    console.log('The count is now:', count.state);
  },
  // Array of `Store`s or `Derived`s
  deps: [count],
  // Should effect run immediately, default is false
  eager: true
})

// Must mount the effect to start listening for updates
const unmount = effect.mount();

// Later, to cleanup
unmount();
```</doc></docs><tutorials><doc title="README" desc="install &amp; quickstart."># Simple

This project was generated with [Angular CLI](https://github.com/angular/angular-cli) version 17.0.1.

## Development server

Run `ng serve` for a dev server. Navigate to `http://localhost:4200/`. The application will automatically reload if you change any of the source files.

## Code scaffolding

Run `ng generate component component-name` to generate a new component. You can also use `ng generate directive|pipe|service|class|guard|interface|enum|module`.

## Build

Run `ng build` to build the project. The build artifacts will be stored in the `dist/` directory.

## Running unit tests

Run `ng test` to execute the unit tests via [Karma](https://karma-runner.github.io).

## Running end-to-end tests

Run `ng e2e` to execute the end-to-end tests via a platform of your choice. To use this command, you need to first add a package that implements end-to-end testing capabilities.

## Further help

To get more help on the Angular CLI use `ng help` or go check out the [Angular CLI Overview and Command Reference](https://angular.io/cli) page.</doc><doc title="README" desc="install &amp; quickstart."># Example

To run this example:

- `npm install`
- `npm run dev`</doc><doc title="README" desc="install &amp; quickstart.">## Usage

```bash
$ npm install # or pnpm install or yarn install
```

### Learn more on the [Solid Website](https://solidjs.com) and come chat with us on our [Discord](https://discord.com/invite/solidjs)

## Available Scripts

In the project directory, you can run:

### `npm run dev`

Runs the app in the development mode.<br>
Open [http://localhost:5173](http://localhost:5173) to view it in the browser.

### `npm run build`

Builds the app for production to the `dist` folder.<br>
It correctly bundles Solid in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br>
Your app is ready to be deployed!

## Deployment

Learn more about deploying your application with the [documentations](https://vitejs.dev/guide/static-deploy.html)</doc><doc title="README" desc="install &amp; quickstart."># Svelte + TS + Vite

This template should help get you started developing with Svelte and TypeScript in Vite.

## Recommended IDE Setup

[VS Code](https://code.visualstudio.com/) + [Svelte](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode).

## Need an official Svelte framework?

Check out [SvelteKit](https://github.com/sveltejs/kit#readme), which is also powered by Vite. Deploy anywhere with its serverless-first approach and adapt to various platforms, with out of the box support for TypeScript, SCSS, and Less, and easily-added support for mdsvex, GraphQL, PostCSS, Tailwind CSS, and more.

## Technical considerations

**Why use this over SvelteKit?**

- It brings its own routing solution which might not be preferable for some users.
- It is first and foremost a framework that just happens to use Vite under the hood, not a Vite app.

This template contains as little as possible to get started with Vite + TypeScript + Svelte, while taking into account the developer experience with regards to HMR and intellisense. It demonstrates capabilities on par with the other `create-vite` templates and is a good starting point for beginners dipping their toes into a Vite + Svelte project.

Should you later need the extended capabilities and extensibility provided by SvelteKit, the template has been structured similarly to SvelteKit so that it is easy to migrate.

**Why `global.d.ts` instead of `compilerOptions.types` inside `jsconfig.json` or `tsconfig.json`?**

Setting `compilerOptions.types` shuts out all other types not explicitly listed in the configuration. Using triple-slash references keeps the default TypeScript setting of accepting type information from the entire workspace, while also adding `svelte` and `vite/client` type information.

**Why include `.vscode/extensions.json`?**

Other templates indirectly recommend extensions via the README, but this file allows VS Code to prompt the user to install the recommended extension upon opening the project.

**Why enable `allowJs` in the TS template?**

While `allowJs: false` would indeed prevent the use of `.js` files in the project, it does not prevent the use of JavaScript syntax in `.svelte` files. In addition, it would force `checkJs: false`, bringing the worst of both worlds: not being able to guarantee the entire codebase is TypeScript, and also having worse typechecking for the existing JavaScript. In addition, there are valid use cases in which a mixed codebase may be relevant.

**Why is HMR not preserving my local component state?**

HMR state preservation comes with a number of gotchas! It has been disabled by default in both `svelte-hmr` and `@sveltejs/vite-plugin-svelte` due to its often surprising behavior. You can read the details [here](https://github.com/rixo/svelte-hmr#svelte-hmr).

If you have state that's important to retain within a component, consider creating an external store which would not be replaced by HMR.

```ts
// store.ts
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)
```</doc><doc title="README" desc="install &amp; quickstart."># Basic example

To run this example:

- `npm install` or `yarn` or `pnpm i`
- `npm run dev` or `yarn dev` or `pnpm dev`</doc><doc title="Simple" desc="worked example."><!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/emblem-light.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />

    <title>TanStack Store React Simple Example App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html></doc><doc title="Simple" desc="worked example."><!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TanStack Store Solid Simple Example App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html></doc><doc title="Simple" desc="worked example."><!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TanStack Store Svelte Simple Example App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html></doc><doc title="Simple" desc="worked example."><!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TanStack Store Vue Simple Example App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html></doc><doc title="Src" desc="worked example."><!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Simple</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
  </head>
  <body>
    <app-root></app-root>
  </body>
</html></doc></tutorials><packages><doc title="Eslint.Config" desc="docs page.">// @ts-check

import rootConfig from '../../eslint.config.js'

export default [...rootConfig]</doc><doc title="Eslint.Config" desc="docs page.">// @ts-check

import pluginReact from '@eslint-react/eslint-plugin'
import pluginReactHooks from 'eslint-plugin-react-hooks'
import rootConfig from '../../eslint.config.js'

export default [
  ...rootConfig,
  {
    files: ['**/*.{ts,tsx}'],
    ...pluginReact.configs.recommended,
  },
  {
    plugins: {
      'react-hooks': pluginReactHooks,
    },
    rules: {
      'react-hooks/exhaustive-deps': 'error',
      'react-hooks/rules-of-hooks': 'error',
    },
  },
]</doc><doc title="Eslint.Config" desc="docs page.">// @ts-check

import rootConfig from '../../eslint.config.js'

export default [...rootConfig]</doc><doc title="Eslint.Config" desc="docs page.">// @ts-check

import rootConfig from '../../eslint.config.js'

export default [...rootConfig]</doc><doc title="Eslint.Config" desc="docs page.">// @ts-check

import pluginSvelte from 'eslint-plugin-svelte'
import rootConfig from '../../eslint.config.js'

export default [
  ...rootConfig,
  ...pluginSvelte.configs['flat/recommended'],
  {
    rules: {
      'svelte/block-lang': ['error', { script: ['ts'] }],
      'svelte/no-svelte-internal': 'error',
      'svelte/valid-compile': 'off',
    },
  },
]</doc><doc title="Eslint.Config" desc="docs page.">// @ts-check

import rootConfig from '../../eslint.config.js'

export default [...rootConfig]</doc><doc title="Svelte.Config" desc="docs page.">import { vitePreprocess } from '@sveltejs/vite-plugin-svelte'

const config = {
  preprocess: vitePreprocess(),
}

export default config</doc><doc title="Vite.Config" desc="docs page.">import { defineConfig } from 'vitest/config'
import packageJson from './package.json'

export default defineConfig({
  test: {
    name: packageJson.name,
    dir: './tests',
    watch: false,
    environment: 'jsdom',
    setupFiles: ['./tests/test-setup.ts'],
    coverage: { enabled: true, provider: 'istanbul', include: ['src/**/*'] },
    typecheck: { enabled: true },
    globals: true,
  },
})</doc><doc title="Vite.Config" desc="docs page.">import { defineConfig, mergeConfig } from 'vitest/config'
import { tanstackViteConfig } from '@tanstack/config/vite'
import react from '@vitejs/plugin-react'
import packageJson from './package.json'

const config = defineConfig({
  plugins: [react()],
  test: {
    name: packageJson.name,
    dir: './tests',
    watch: false,
    environment: 'jsdom',
    setupFiles: ['./tests/test-setup.ts'],
    coverage: { enabled: true, provider: 'istanbul', include: ['src/**/*'] },
    typecheck: { enabled: true },
  },
})

export default mergeConfig(
  config,
  tanstackViteConfig({
    entry: './src/index.ts',
    srcDir: './src',
  }),
)</doc><doc title="Vite.Config" desc="docs page.">import { defineConfig, mergeConfig } from 'vitest/config'
import { tanstackViteConfig } from '@tanstack/config/vite'
import solid from 'vite-plugin-solid'
import packageJson from './package.json'

const config = defineConfig({
  plugins: [solid()],
  test: {
    name: packageJson.name,
    dir: './tests',
    watch: false,
    environment: 'jsdom',
    setupFiles: ['./tests/test-setup.ts'],
    coverage: { enabled: true, provider: 'istanbul', include: ['src/**/*'] },
    typecheck: { enabled: true },
  },
})

export default mergeConfig(
  config,
  tanstackViteConfig({
    entry: ['./src/index.tsx'],
    srcDir: './src',
  }),
)</doc></packages><scripts><doc title="Publish" desc="docs page.">// @ts-check

import { resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { publish } from '@tanstack/config/publish'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

await publish({
  packages: [
    {
      name: '@tanstack/store',
      packageDir: 'packages/store',
    },
    {
      name: '@tanstack/react-store',
      packageDir: 'packages/react-store',
    },
    {
      name: '@tanstack/vue-store',
      packageDir: 'packages/vue-store',
    },
    {
      name: '@tanstack/solid-store',
      packageDir: 'packages/solid-store',
    },
    {
      name: '@tanstack/angular-store',
      packageDir: 'packages/angular-store',
    },
    {
      name: '@tanstack/svelte-store',
      packageDir: 'packages/svelte-store',
    },
  ],
  branchConfigs: {
    main: {
      prerelease: false,
    },
    alpha: {
      prerelease: true,
    },
    beta: {
      prerelease: true,
    },
  },
  rootDir: resolve(__dirname, '..'),
  branch: process.env.BRANCH,
  tag: process.env.TAG,
  ghToken: process.env.GH_TOKEN,
})

process.exit(0)</doc><doc title="Verify Links" desc="docs page.">import { existsSync, readFileSync, statSync } from 'node:fs'
import path, { resolve } from 'node:path'
import { glob } from 'tinyglobby'
// @ts-ignore Could not find a declaration file for module 'markdown-link-extractor'.
import markdownLinkExtractor from 'markdown-link-extractor'

function isRelativeLink(link: string) {
  return (
    link &&
    !link.startsWith('http://') &&
    !link.startsWith('https://') &&
    !link.startsWith('//') &&
    !link.startsWith('#') &&
    !link.startsWith('mailto:')
  )
}

function normalizePath(p: string): string {
  // Remove any trailing .md
  p = p.replace(`${path.extname(p)}`, '')
  return p
}

function fileExistsForLink(
  link: string,
  markdownFile: string,
  errors: Array<any>,
): boolean {
  // Remove hash if present
  const filePart = link.split('#')[0]
  // If the link is empty after removing hash, it's not a file
  if (!filePart) return false

  // Normalize the markdown file path
  markdownFile = normalizePath(markdownFile)

  // Normalize the path
  const normalizedPath = normalizePath(filePart)

  // Resolve the path relative to the markdown file's directory
  let absPath = resolve(markdownFile, normalizedPath)

  // Ensure the resolved path is within /docs
  const docsRoot = resolve('docs')
  if (!absPath.startsWith(docsRoot)) {
    errors.push({
      link,
      markdownFile,
      resolvedPath: absPath,
      reason: 'navigates above /docs, invalid',
    })
    return false
  }

  // Check if this is an example path
  const isExample = absPath.includes('/examples/')

  let exists = false

  if (isExample) {
    // Transform /docs/framework/{framework}/examples/ to /examples/{framework}/
    absPath = absPath.replace(
      /\/docs\/framework\/([^/]+)\/examples\//,
      '/examples/$1/',
    )
    // For examples, we want to check if the directory exists
    exists = existsSync(absPath) && statSync(absPath).isDirectory()
  } else {
    // For non-examples, we want to check if the .md file exists
    if (!absPath.endsWith('.md')) {
      absPath = `${absPath}.md`
    }
    exists = existsSync(absPath)
  }

  if (!exists) {
    errors.push({
      link,
      markdownFile,
      resolvedPath: absPath,
      reason: 'not found',
    })
  }
  return exists
}

async function findMarkdownLinks() {
  // Find all markdown files in docs directory
  const markdownFiles = await glob('docs/**/*.md', {
    ignore: ['**/node_modules/**'],
  })

  console.log(`Found ${markdownFiles.length} markdown files\n`)

  const errors: Array<any> = []

  // Process each file
  for (const file of markdownFiles) {
    const content = readFileSync(file, 'utf-8')
    const links: Array<any> = markdownLinkExtractor(content)

    const filteredLinks = links.filter((link: any) => {
      if (typeof link === 'string') {
        return isRelativeLink(link)
      } else if (link && typeof link.href === 'string') {
        return isRelativeLink(link.href)
      }
      return false
    })

    if (filteredLinks.length > 0) {
      filteredLinks.forEach((link) => {
        const href = typeof link === 'string' ? link : link.href
        fileExistsForLink(href, file, errors)
      })
    }
  }

  if (errors.length > 0) {
    console.log(`\n❌ Found ${errors.length} broken links:`)
    errors.forEach((err) => {
      console.log(
        `${err.link}\n  in:    ${err.markdownFile}\n  path:  ${err.resolvedPath}\n  why:   ${err.reason}\n`,
      )
    })
    process.exit(1)
  } else {
    console.log('\n✅ No broken links found!')
  }
}

findMarkdownLinks().catch(console.error)</doc></scripts></project>
