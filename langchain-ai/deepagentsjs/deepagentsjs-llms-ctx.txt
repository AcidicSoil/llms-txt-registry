<project title="Deepagentsjs" summary="`deepagentsjs` is a TypeScript library that enables the creation of **deep agents**â€”LLMâ€‘based agents capable of planning, executing subâ€‘tasks, managing large amounts of context via a file system, and persisting memory across interactions.   Its primary goal is to move beyond the shallow â€œtoolâ€‘callingâ€ loop by providing builtâ€‘in planning tools, subâ€‘agent spawning, and persistent storage, making it suitable for complex, longâ€‘running applications such as research assistants, code generation pipelines, and interactive humanâ€‘inâ€‘theâ€‘loop workflows.">**Remember:**
- Deep Agent
- Planning tool (write_todos)
- Subâ€‘agents (task tool)
- Fileâ€‘system middleware (ls, read_file, write_file, edit_file, glob, grep)
- Store backend (persistent memory)
- Composite backend (combines multiple backends)<tutorials><doc title="Composite Backend" desc="worked example.">import "dotenv/config";
import { z } from "zod";
import { tool } from "langchain";
import { TavilySearch } from "@langchain/tavily";
import { ChatAnthropic } from "@langchain/anthropic";
import { HumanMessage } from "@langchain/core/messages";
import { MemorySaver, InMemoryStore } from "@langchain/langgraph-checkpoint";
import { v4 as uuidv4 } from "uuid";

import {
  createDeepAgent,
  CompositeBackend,
  StateBackend,
  StoreBackend,
} from "../../src/index.js";

const internetSearch = tool(
  async ({ query, maxResults = 5 }: { query: string; maxResults?: number }) => {
    const tavilySearch = new TavilySearch({
      maxResults,
      tavilyApiKey: process.env.TAVILY_API_KEY,
    });
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const tavilyResponse = await tavilySearch._call({ query });
    return tavilyResponse;
  },
  {
    name: "internet_search",
    description: "Run a web search",
    schema: z.object({
      query: z.string().describe("The search query"),
      maxResults: z
        .number()
        .optional()
        .default(5)
        .describe("Maximum number of results to return"),
    }),
  },
);

const systemPrompt = `You are a research assistant with both temporary and persistent storage.

## Storage Types

1. **Temporary files** (root directory): Stored in state, lost after conversation
   - Use for: scratch notes, intermediate work
   - Example: \`/research_notes.txt\`, \`/draft.md\`

2. **Persistent memory** (\`/memories/\` directory): Stored in database, kept forever
   - Use for: final reports, important findingss
   - Example: \`/memories/report_2025_ai_trends.md\`

## Workflow

1. Write your research question to \`/research_question.txt\` (temporary)
2. Gather information using the internet_search tool
3. Write your findings to \`/research_notes.txt\` (temporary) as you discover them
4. Once you have enough information, write a final summary to \`/summary.md\` (temporary)
5. **IMPORTANT**: Save the final report to \`/memories/report_TOPIC.md\` (persistent)

## Memory Guidelines

Always save completed reports to \`/memories/\` so they can be referenced in future conversations.
Use descriptive filenames like:
- \`/memories/report_ai_agents_2025.md\`
- \`/memories/findings_quantum_computing.md\`
- \`/memories/summary_market_analysis.md\``;

export const agent = createDeepAgent({
  model: new ChatAnthropic({
    model: "claude-sonnet-4-20250514",
    temperature: 0,
  }),
  tools: [internetSearch],
  systemPrompt,
  checkpointer: new MemorySaver(),
  store: new InMemoryStore(),
  backend: (config) =>
    new CompositeBackend(new StateBackend(config), {
      "/memories/": new StoreBackend(config),
    }),
});

async function main() {
  const threadId = uuidv4();

  await agent.invoke(
    {
      messages: [
        new HumanMessage("Research the latest trends in AI agents for 2025"),
      ],
    },
    {
      recursionLimit: 50,
      configurable: { thread_id: threadId },
    },
  );

  const threadId2 = uuidv4();
  await agent.invoke(
    {
      messages: [
        new HumanMessage(
          "Do you have any info on the latest trends in AI agents for 2025?",
        ),
      ],
    },
    {
      recursionLimit: 50,
      configurable: { thread_id: threadId2 },
    },
  );
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}</doc><doc title="Filesystem Backend" desc="worked example.">import "dotenv/config";
import { ChatAnthropic } from "@langchain/anthropic";
import { HumanMessage } from "@langchain/core/messages";
import * as path from "path";

import { createDeepAgent, FilesystemBackend } from "../../src/index.js";

const systemPrompt = `You are an expert coding assistant with access to the real filesystem.

You can read and write files directly to the filesystem in your working directory.
This makes you perfect for real coding tasks that need to persist on disk.

## Workflow

1. Read existing code files to understand the project structure
2. Create new files or edit existing ones as needed
3. Write implementation plans and documentation

## Important

- All files you create are written to the actual filesystem
- Use the current working directory as your workspace
- You can use standard filesystem tools (ls, read_file, write_file, edit_file)
- Files persist after the conversation ends`;

const workspaceDir = path.join(process.cwd(), "workspace");

export const agent = createDeepAgent({
  model: new ChatAnthropic({
    model: "claude-sonnet-4-20250514",
    temperature: 0,
  }),
  systemPrompt,
  backend: new FilesystemBackend({
    rootDir: workspaceDir,
    virtualMode: true,
  }),
});

async function main() {
  await agent.invoke(
    {
      messages: [
        new HumanMessage(
          "Create a simple TypeScript utility function that validates email addresses.",
        ),
      ],
    },
    { recursionLimit: 50 },
  );
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}</doc><doc title="Research Agent" desc="worked example.">import "dotenv/config";
import { z } from "zod";
import { tool } from "langchain";
import { TavilySearch } from "@langchain/tavily";
import { ChatAnthropic } from "@langchain/anthropic";

import { createDeepAgent, type SubAgent } from "../../src/index.js";

type Topic = "general" | "news" | "finance";

// Search tool to use to do research
const internetSearch = tool(
  async ({
    query,
    maxResults = 5,
    topic = "general" as Topic,
    includeRawContent = false,
  }: {
    query: string;
    maxResults?: number;
    topic?: Topic;
    includeRawContent?: boolean;
  }) => {
    /**
     * Run a web search
     */

    // Note: You'll need to install and import tavily-js or similar package
    // For now, this is a placeholder that shows the structure
    const tavilySearch = new TavilySearch({
      maxResults,
      tavilyApiKey: process.env.TAVILY_API_KEY,
      includeRawContent,
      topic,
    });
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore - Type instantiation is excessively deep and possibly infinite.
    const tavilyResponse = await tavilySearch._call({ query });

    return tavilyResponse;
  },
  {
    name: "internet_search",
    description: "Run a web search",
    schema: z.object({
      query: z.string().describe("The search query"),
      maxResults: z
        .number()
        .optional()
        .default(5)
        .describe("Maximum number of results to return"),
      topic: z
        .enum(["general", "news", "finance"])
        .optional()
        .default("general")
        .describe("Search topic category"),
      includeRawContent: z
        .boolean()
        .optional()
        .default(false)
        .describe("Whether to include raw content"),
    }),
  },
);

const subResearchPrompt = `You are a dedicated researcher. Your job is to conduct research based on the users questions.

CConduct thorough research and then reply to the user with a detailed answer to their question

only your FINAL answer will be passed on to the user. They will have NO knowledge of anything except your final message, so your final report should be your final message!`;

const researchSubAgent: SubAgent = {
  name: "research-agent",
  description:
    "Used to research more in depth questions. Only give this researcher one topic at a time. Do not pass multiple sub questions to this researcher. Instead, you should break down a large topic into the necessary components, and then call multiple research agents in parallel, one for each sub question.",
  systemPrompt: subResearchPrompt,
  tools: [internetSearch],
};

const subCritiquePrompt = `You are a dedicated editor. You are being tasked to critique a report.

You can find the report at \`final_report.md\`.

You can find the question/topic for this report at \`question.txt\`.

The user may ask for specific areas to critique the report in. Respond to the user with a detailed critique of the report. Things that could be improved.

You can use the search tool to search for information, if that will help you critique the report

Do not write to the \`final_report.md\` yourself.

Things to check:
- Check that each section is appropriately named
- Check that the report is written as you would find in an essay or a textbook - it should be text heavy, do not let it just be a list of bullet points!
- Check that the report is comprehensive. If any paragraphs or sections are short, or missing important details, point it out.
- Check that the article covers key areas of the industry, ensures overall understanding, and does not omit important parts.
- Check that the article deeply analyzes causes, impacts, and trends, providing valuable insights
- Check that the article closely follows the research topic and directly answers questions
- Check that the article has a clear structure, fluent language, and is easy to understand.
`;

const critiqueSubAgent: SubAgent = {
  name: "critique-agent",
  description:
    "Used to critique the final report. Give this agent some infomration about how you want it to critique the report.",
  systemPrompt: subCritiquePrompt,
};

// Prompt prefix to steer the agent to be an expert researcher
const researchInstructions = `You are an expert researcher. Your job is to conduct thorough research, and then write a polished report.

The first thing you should do is to write the original user question to \`question.txt\` so you have a record of it.

Use the research-agent to conduct deep research. It will respond to your questions/topics with a detailed answer.

When you think you enough information to write a final report, write it to \`final_report.md\`

You can call the critique-agent to get a critique of the final report. After that (if needed) you can do more research and edit the \`final_report.md\`
You can do this however many times you want until are you satisfied with the result.

Only edit the file once at a time (if you call this tool in parallel, there may be conflicts).

Here are instructions for writing the final report:

<report_instructions>

CRITICAL: Make sure the answer is written in the same language as the human messages! If you make a todo plan - you should note in the plan what language the report should be in so you dont forget!
Note: the language the report should be in is the language the QUESTION is in, not the language/country that the question is ABOUT.

Please create a detailed answer to the overall research brief that:
1. Is well-organized with proper headings (# for title, ## for sections, ### for subsections)
2. Includes specific facts and insights from the research
3. References relevant sources using [Title](URL) format
4. Provides a balanced, thorough analysis. Be as comprehensive as possible, and include all information that is relevant to the overall research question. People are using you for deep research and will expect detailed, comprehensive answers.
5. Includes a "Sources" section at the end with all referenced links

You can structure your report in a number of different ways. Here are some examples:

To answer a question that asks you to compare two things, you might structure your report like this:
1/ intro
2/ overview of topic A
3/ overview of topic B
4/ comparison between A and B
5/ conclusion

To answer a question that asks you to return a list of things, you might only need a single section which is the entire list.
1/ list of things or table of things
Or, you could choose to make each item in the list a separate section in the report. When asked for lists, you don't need an introduction or conclusion.
1/ item 1
2/ item 2
3/ item 3

To answer a question that asks you to summarize a topic, give a report, or give an overview, you might structure your report like this:
1/ overview of topic
2/ concept 1
3/ concept 2
4/ concept 3
5/ conclusion

If you think you can answer the question with a single section, you can do that too!
1/ answer

REMEMBER: Section is a VERY fluid and loose concept. You can structure your report however you think is best, including in ways that are not listed above!
Make sure that your sections are cohesive, and make sense for the reader.

For each section of the report, do the following:
- Use simple, clear language
- Use ## for section title (Markdown format) for each section of the report
- Do NOT ever refer to yourself as the writer of the report. This should be a professional report without any self-referential language. 
- Do not say what you are doing in the report. Just write the report without any commentary from yourself.
- Each section should be as long as necessary to deeply answer the question with the information you have gathered. It is expected that sections will be fairly long and verbose. You are writing a deep research report, and users will expect a thorough answer.
- Use bullet points to list out information when appropriate, but by default, write in paragraph form.

REMEMBER:
The brief and research may be in English, but you need to translate this information to the right language when writing the final answer.
Make sure the final answer report is in the SAME language as the human messages in the message history.

Format the report in clear markdown with proper structure and include source references where appropriate.

<Citation Rules>
- Assign each unique URL a single citation number in your text
- End with ### Sources that lists each source with corresponding numbers
- IMPORTANT: Number sources sequentially without gaps (1,2,3,4...) in the final list regardless of which sources you choose
- Each source should be a separate line item in a list, so that in markdown it is rendered as a list.
- Example format:
  [1] Source Title: URL
  [2] Source Title: URL
- Citations are extremely important. Make sure to include these, and pay a lot of attention to getting these right. Users will often use these citations to look into more information.
</Citation Rules>
</report_instructions>

You have access to a few tools.

## \`internet_search\`

Use this to run an internet search for a given query. You can specify the number of results, the topic, and whether raw content should be included.
`;

// Create the agent
export const agent = createDeepAgent({
  model: new ChatAnthropic({
    model: "claude-sonnet-4-20250514",
    temperature: 0,
  }),
  tools: [internetSearch],
  systemPrompt: researchInstructions,
  subagents: [critiqueSubAgent, researchSubAgent],
});

// // Invoke the agent
// async function main() {
//   const result = await agent.invoke(
//     {
//       messages: [new HumanMessage("what is langgraph?")],
//     },
//     { recursionLimit: 1000 }
//   );

//   console.log("ðŸŽ‰ Finished!");
//   console.log(
//     `\n\nAgent ToDo List:\n${result.todos.map((todo) => ` - ${todo.content} (${todo.status})`).join("\n")}`
//   );
//   console.log(
//     `\n\nAgent Files:\n${Object.entries(result.files)
//       .map(([key, value]) => ` - ${key}: ${value}`)
//       .join("\n")}`
//   );
// }

// // Run if this file is executed directly
// if (import.meta.url === `file://${process.argv[1]}`) {
//   main();
// }</doc><doc title="State Backend" desc="worked example.">import "dotenv/config";
import { z } from "zod";
import { tool } from "langchain";
import { TavilySearch } from "@langchain/tavily";
import { ChatAnthropic } from "@langchain/anthropic";
import { HumanMessage } from "@langchain/core/messages";

import { createDeepAgent, StateBackend } from "../../src/index.js";

const internetSearch = tool(
  async ({ query, maxResults = 5 }: { query: string; maxResults?: number }) => {
    const tavilySearch = new TavilySearch({
      maxResults,
      tavilyApiKey: process.env.TAVILY_API_KEY,
    });
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const tavilyResponse = await tavilySearch._call({ query });
    return tavilyResponse;
  },
  {
    name: "internet_search",
    description: "Run a web search",
    schema: z.object({
      query: z.string().describe("The search query"),
      maxResults: z
        .number()
        .optional()
        .default(5)
        .describe("Maximum number of results to return"),
    }),
  },
);

const systemPrompt = `You are a research assistant.

Your files are stored in memory and will be lost when the conversation ends.

## Workflow

1. Write your research question to \`research_question.txt\`
2. Gather information using the internet_search tool
3. Write your findings to \`research_notes.txt\` as you discover them
4. Once you have enough information, write a final summary to \`summary.md\``;

export const agent = createDeepAgent({
  model: new ChatAnthropic({
    model: "claude-sonnet-4-20250514",
    temperature: 0,
  }),
  tools: [internetSearch],
  systemPrompt,
  backend: (config) => new StateBackend(config),
});

async function main() {
  await agent.invoke(
    {
      messages: [
        new HumanMessage("Research the latest trends in AI agents for 2025"),
      ],
    },
    { recursionLimit: 50 },
  );
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}</doc><doc title="Store Backend" desc="worked example.">import "dotenv/config";
import { z } from "zod";
import { tool } from "langchain";
import { TavilySearch } from "@langchain/tavily";
import { ChatAnthropic } from "@langchain/anthropic";
import { HumanMessage } from "@langchain/core/messages";
import { MemorySaver, InMemoryStore } from "@langchain/langgraph-checkpoint";

import { createDeepAgent, StoreBackend } from "../../src/index.js";
import { v4 as uuidv4 } from "uuid";

const internetSearch = tool(
  async ({ query, maxResults = 5 }: { query: string; maxResults?: number }) => {
    const tavilySearch = new TavilySearch({
      maxResults,
      tavilyApiKey: process.env.TAVILY_API_KEY,
    });
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const tavilyResponse = await tavilySearch._call({ query });
    return tavilyResponse;
  },
  {
    name: "internet_search",
    description: "Run a web search",
    schema: z.object({
      query: z.string().describe("The search query"),
      maxResults: z
        .number()
        .optional()
        .default(5)
        .describe("Maximum number of results to return"),
    }),
  },
);

const systemPrompt = `You are a research assistant with persistent cross-conversation storage.

Your files persist across all conversations and threads using the store.

## Workflow

1. Write your research question to \`research_question.txt\`
2. Gather information using the internet_search tool
3. Write your findings to \`research_notes.txt\` as you discover them
4. Once you have enough information, write a final summary to \`summary.md\`

## Important

All files you create are shared across ALL conversations. This means you can reference
previous research in new conversations.`;

export const agent = createDeepAgent({
  model: new ChatAnthropic({
    model: "claude-sonnet-4-20250514",
    temperature: 0,
  }),
  tools: [internetSearch],
  systemPrompt,
  checkpointer: new MemorySaver(),
  store: new InMemoryStore(),
  backend: (config) => new StoreBackend(config),
});

async function main() {
  const threadId = uuidv4();

  await agent.invoke(
    {
      messages: [
        new HumanMessage("Research the latest trends in AI agents for 2025"),
      ],
    },
    {
      recursionLimit: 50,
      configurable: { thread_id: threadId },
    },
  );

  const threadId2 = uuidv4();
  await agent.invoke(
    {
      messages: [
        new HumanMessage(
          "Do you have any info on the latest trends in AI agents for 2025?",
        ),
      ],
    },
    {
      recursionLimit: 50,
      configurable: { thread_id: threadId2 },
    },
  );
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}</doc></tutorials><.changeset><doc title="README" desc="install &amp; quickstart."># Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)</doc><doc title="Itchy Needles Admire" desc="docs page.">---
"deepagents": patch
---

thread config options to subagents</doc></.changeset><src><doc title="Agent" desc="docs page.">import {
  createAgent,
  humanInTheLoopMiddleware,
  anthropicPromptCachingMiddleware,
  todoListMiddleware,
  summarizationMiddleware,
  type AgentMiddleware,
  type ReactAgent,
  type InterruptOnConfig,
} from "langchain";
import type { StructuredTool } from "@langchain/core/tools";
import type { BaseLanguageModel } from "@langchain/core/language_models/base";
import type {
  BaseCheckpointSaver,
  BaseStore,
} from "@langchain/langgraph-checkpoint";

import {
  createFilesystemMiddleware,
  createSubAgentMiddleware,
  createPatchToolCallsMiddleware,
  type SubAgent,
} from "./middleware/index.js";
import { StateBackend, type BackendProtocol } from "./backends/index.js";
import { InteropZodObject } from "@langchain/core/utils/types";
import { AnnotationRoot } from "@langchain/langgraph";

/**
 * Configuration parameters for creating a Deep Agent
 * Matches Python's create_deep_agent parameters
 */
export interface CreateDeepAgentParams<
  ContextSchema extends
    | AnnotationRoot<any>
    | InteropZodObject = AnnotationRoot<any>,
> {
  /** The model to use (model name string or LanguageModelLike instance). Defaults to claude-sonnet-4-5-20250929 */
  model?: BaseLanguageModel | string;
  /** Tools the agent should have access to */
  tools?: StructuredTool[];
  /** Custom system prompt for the agent. This will be combined with the base agent prompt */
  systemPrompt?: string;
  /** Custom middleware to apply after standard middleware */
  middleware?: AgentMiddleware[];
  /** List of subagent specifications for task delegation */
  subagents?: SubAgent[];
  /** Structured output response format for the agent */
  responseFormat?: any; // ResponseFormat type is complex, using any for now
  /** Optional schema for context (not persisted between invocations) */
  contextSchema?: ContextSchema;
  /** Optional checkpointer for persisting agent state between runs */
  checkpointer?: BaseCheckpointSaver | boolean;
  /** Optional store for persisting longterm memories */
  store?: BaseStore;
  /**
   * Optional backend for filesystem operations.
   * Can be either a backend instance or a factory function that creates one.
   * The factory receives a config object with state and store.
   */
  backend?:
    | BackendProtocol
    | ((config: { state: unknown; store?: BaseStore }) => BackendProtocol);
  /** Optional interrupt configuration mapping tool names to interrupt configs */
  interruptOn?: Record<string, boolean | InterruptOnConfig>;
  /** The name of the agent */
  name?: string;
}

const BASE_PROMPT = `In order to complete the objective that the user asks of you, you have access to a number of standard tools.`;

/**
 * Create a Deep Agent with middleware-based architecture.
 *
 * Matches Python's create_deep_agent function, using middleware for all features:
 * - Todo management (todoListMiddleware)
 * - Filesystem tools (createFilesystemMiddleware)
 * - Subagent delegation (createSubAgentMiddleware)
 * - Conversation summarization (summarizationMiddleware)
 * - Prompt caching (anthropicPromptCachingMiddleware)
 * - Tool call patching (createPatchToolCallsMiddleware)
 * - Human-in-the-loop (humanInTheLoopMiddleware) - optional
 *
 * @param params Configuration parameters for the agent
 * @returns ReactAgent instance ready for invocation
 */
export function createDeepAgent<
  ContextSchema extends
    | AnnotationRoot<any>
    | InteropZodObject = AnnotationRoot<any>,
>(
  params: CreateDeepAgentParams<ContextSchema> = {},
): ReactAgent<any, any, ContextSchema, any> {
  const {
    model = "claude-sonnet-4-5-20250929",
    tools = [],
    systemPrompt,
    middleware: customMiddleware = [],
    subagents = [],
    responseFormat,
    contextSchema,
    checkpointer,
    store,
    backend,
    interruptOn,
    name,
  } = params;

  // Combine system prompt with base prompt like Python implementation
  const finalSystemPrompt = systemPrompt
    ? `${systemPrompt}\n\n${BASE_PROMPT}`
    : BASE_PROMPT;

  // Create backend configuration for filesystem middleware
  // If no backend is provided, use a factory that creates a StateBackend
  const filesystemBackend = backend
    ? backend
    : (config: { state: unknown; store?: BaseStore }) =>
        new StateBackend(config);

  const middleware: AgentMiddleware[] = [
    // Provides todo list management capabilities for tracking tasks
    todoListMiddleware(),
    // Enables filesystem operations and optional long-term memory storage
    createFilesystemMiddleware({ backend: filesystemBackend }),
    // Enables delegation to specialized subagents for complex tasks
    createSubAgentMiddleware({
      defaultModel: model,
      defaultTools: tools,
      defaultMiddleware: [
        // Subagent middleware: Todo list management
        todoListMiddleware(),
        // Subagent middleware: Filesystem operations
        createFilesystemMiddleware({
          backend: filesystemBackend,
        }),
        // Subagent middleware: Automatic conversation summarization when token limits are approached
        summarizationMiddleware({
          model,
          maxTokensBeforeSummary: 170000,
          messagesToKeep: 6,
        }),
        // Subagent middleware: Anthropic prompt caching for improved performance
        anthropicPromptCachingMiddleware({
          unsupportedModelBehavior: "ignore",
        }),
        // Subagent middleware: Patches tool calls for compatibility
        createPatchToolCallsMiddleware(),
      ],
      defaultInterruptOn: interruptOn,
      subagents,
      generalPurposeAgent: true,
    }),
    // Automatically summarizes conversation history when token limits are approached
    summarizationMiddleware({
      model,
      maxTokensBeforeSummary: 170000,
      messagesToKeep: 6,
    }),
    // Enables Anthropic prompt caching for improved performance and reduced costs
    anthropicPromptCachingMiddleware({
      unsupportedModelBehavior: "ignore",
    }),
    // Patches tool calls to ensure compatibility across different model providers
    createPatchToolCallsMiddleware(),
  ];

  // Add human-in-the-loop middleware if interrupt config provided
  if (interruptOn) {
    middleware.push(humanInTheLoopMiddleware({ interruptOn }));
  }

  // Add custom middleware last (after all built-in middleware)
  middleware.push(...customMiddleware);

  return createAgent({
    model,
    systemPrompt: finalSystemPrompt,
    tools,
    middleware,
    responseFormat,
    contextSchema,
    checkpointer,
    store,
    name,
  });
}</doc><doc title="Index" desc="docs page.">/**
 * Deep Agents TypeScript Implementation
 *
 * A TypeScript port of the Python Deep Agents library for building controllable AI agents with LangGraph.
 * This implementation maintains 1:1 compatibility with the Python version.
 */

export { createDeepAgent, type CreateDeepAgentParams } from "./agent.js";

// Export middleware
export {
  createFilesystemMiddleware,
  createSubAgentMiddleware,
  createPatchToolCallsMiddleware,
  type FilesystemMiddlewareOptions,
  type SubAgentMiddlewareOptions,
  type SubAgent,
  type FileData,
} from "./middleware/index.js";

// Export backends
export {
  StateBackend,
  StoreBackend,
  FilesystemBackend,
  CompositeBackend,
  type BackendProtocol,
  type BackendFactory,
  type FileInfo,
  type GrepMatch,
  type WriteResult,
  type EditResult,
} from "./backends/index.js";</doc><doc title="Composite" desc="docs page.">/**
 * CompositeBackend: Route operations to different backends based on path prefix.
 */

import type {
  BackendProtocol,
  EditResult,
  FileInfo,
  GrepMatch,
  WriteResult,
} from "./protocol.js";

/**
 * Backend that routes file operations to different backends based on path prefix.
 *
 * This enables hybrid storage strategies like:
 * - `/memories/` â†’ StoreBackend (persistent, cross-thread)
 * - Everything else â†’ StateBackend (ephemeral, per-thread)
 *
 * The CompositeBackend handles path prefix stripping/re-adding transparently.
 */
export class CompositeBackend implements BackendProtocol {
  private default: BackendProtocol;
  private routes: Record<string, BackendProtocol>;
  private sortedRoutes: Array<[string, BackendProtocol]>;

  constructor(
    defaultBackend: BackendProtocol,
    routes: Record<string, BackendProtocol>,
  ) {
    this.default = defaultBackend;
    this.routes = routes;

    // Sort routes by length (longest first) for correct prefix matching
    this.sortedRoutes = Object.entries(routes).sort(
      (a, b) => b[0].length - a[0].length,
    );
  }

  /**
   * Determine which backend handles this key and strip prefix.
   *
   * @param key - Original file path
   * @returns Tuple of [backend, stripped_key] where stripped_key has the route
   *          prefix removed (but keeps leading slash).
   */
  private getBackendAndKey(key: string): [BackendProtocol, string] {
    // Check routes in order of length (longest first)
    for (const [prefix, backend] of this.sortedRoutes) {
      if (key.startsWith(prefix)) {
        // Strip full prefix and ensure a leading slash remains
        // e.g., "/memories/notes.txt" â†’ "/notes.txt"; "/memories/" â†’ "/"
        const suffix = key.substring(prefix.length);
        const strippedKey = suffix ? "/" + suffix : "/";
        return [backend, strippedKey];
      }
    }

    return [this.default, key];
  }

  /**
   * List files and directories in the specified directory (non-recursive).
   *
   * @param path - Absolute path to directory
   * @returns List of FileInfo objects with route prefixes added, for files and directories
   *          directly in the directory. Directories have a trailing / in their path and is_dir=true.
   */
  async lsInfo(path: string): Promise<FileInfo[]> {
    // Check if path matches a specific route
    for (const [routePrefix, backend] of this.sortedRoutes) {
      if (path.startsWith(routePrefix.replace(/\/$/, ""))) {
        // Query only the matching routed backend
        const suffix = path.substring(routePrefix.length);
        const searchPath = suffix ? "/" + suffix : "/";
        const infos = await backend.lsInfo(searchPath);

        // Add route prefix back to paths
        const prefixed: FileInfo[] = [];
        for (const fi of infos) {
          prefixed.push({
            ...fi,
            path: routePrefix.slice(0, -1) + fi.path,
          });
        }
        return prefixed;
      }
    }

    // At root, aggregate default and all routed backends
    if (path === "/") {
      const results: FileInfo[] = [];
      const defaultInfos = await this.default.lsInfo(path);
      results.push(...defaultInfos);

      // Add the route itself as a directory (e.g., /memories/)
      for (const [routePrefix] of this.sortedRoutes) {
        results.push({
          path: routePrefix,
          is_dir: true,
          size: 0,
          modified_at: "",
        });
      }

      results.sort((a, b) => a.path.localeCompare(b.path));
      return results;
    }

    // Path doesn't match a route: query only default backend
    return await this.default.lsInfo(path);
  }

  /**
   * Read file content, routing to appropriate backend.
   *
   * @param filePath - Absolute file path
   * @param offset - Line offset to start reading from (0-indexed)
   * @param limit - Maximum number of lines to read
   * @returns Formatted file content with line numbers, or error message
   */
  async read(
    filePath: string,
    offset: number = 0,
    limit: number = 2000,
  ): Promise<string> {
    const [backend, strippedKey] = this.getBackendAndKey(filePath);
    return await backend.read(strippedKey, offset, limit);
  }

  /**
   * Structured search results or error string for invalid input.
   */
  async grepRaw(
    pattern: string,
    path: string = "/",
    glob: string | null = null,
  ): Promise<GrepMatch[] | string> {
    // If path targets a specific route, search only that backend
    for (const [routePrefix, backend] of this.sortedRoutes) {
      if (path.startsWith(routePrefix.replace(/\/$/, ""))) {
        const searchPath = path.substring(routePrefix.length - 1);
        const raw = await backend.grepRaw(pattern, searchPath || "/", glob);

        if (typeof raw === "string") {
          return raw;
        }

        // Add route prefix back
        return raw.map((m) => ({
          ...m,
          path: routePrefix.slice(0, -1) + m.path,
        }));
      }
    }

    // Otherwise, search default and all routed backends and merge
    const allMatches: GrepMatch[] = [];
    const rawDefault = await this.default.grepRaw(pattern, path, glob);

    if (typeof rawDefault === "string") {
      return rawDefault;
    }

    allMatches.push(...rawDefault);

    // Search all routes
    for (const [routePrefix, backend] of Object.entries(this.routes)) {
      const raw = await backend.grepRaw(pattern, "/", glob);

      if (typeof raw === "string") {
        return raw;
      }

      // Add route prefix back
      allMatches.push(
        ...raw.map((m) => ({
          ...m,
          path: routePrefix.slice(0, -1) + m.path,
        })),
      );
    }

    return allMatches;
  }

  /**
   * Structured glob matching returning FileInfo objects.
   */
  async globInfo(pattern: string, path: string = "/"): Promise<FileInfo[]> {
    const results: FileInfo[] = [];

    // Route based on path, not pattern
    for (const [routePrefix, backend] of this.sortedRoutes) {
      if (path.startsWith(routePrefix.replace(/\/$/, ""))) {
        const searchPath = path.substring(routePrefix.length - 1);
        const infos = await backend.globInfo(pattern, searchPath || "/");

        // Add route prefix back
        return infos.map((fi) => ({
          ...fi,
          path: routePrefix.slice(0, -1) + fi.path,
        }));
      }
    }

    // Path doesn't match any specific route - search default backend AND all routed backends
    const defaultInfos = await this.default.globInfo(pattern, path);
    results.push(...defaultInfos);

    for (const [routePrefix, backend] of Object.entries(this.routes)) {
      const infos = await backend.globInfo(pattern, "/");
      results.push(
        ...infos.map((fi) => ({
          ...fi,
          path: routePrefix.slice(0, -1) + fi.path,
        })),
      );
    }

    // Deterministic ordering
    results.sort((a, b) => a.path.localeCompare(b.path));
    return results;
  }

  /**
   * Create a new file, routing to appropriate backend.
   *
   * @param filePath - Absolute file path
   * @param content - File content as string
   * @returns WriteResult with path or error
   */
  async write(filePath: string, content: string): Promise<WriteResult> {
    const [backend, strippedKey] = this.getBackendAndKey(filePath);
    return await backend.write(strippedKey, content);
  }

  /**
   * Edit a file, routing to appropriate backend.
   *
   * @param filePath - Absolute file path
   * @param oldString - String to find and replace
   * @param newString - Replacement string
   * @param replaceAll - If true, replace all occurrences
   * @returns EditResult with path, occurrences, or error
   */
  async edit(
    filePath: string,
    oldString: string,
    newString: string,
    replaceAll: boolean = false,
  ): Promise<EditResult> {
    const [backend, strippedKey] = this.getBackendAndKey(filePath);
    return await backend.edit(strippedKey, oldString, newString, replaceAll);
  }
}</doc><doc title="Filesystem" desc="docs page.">/**
 * FilesystemBackend: Read and write files directly from the filesystem.
 *
 * Security and search upgrades:
 * - Secure path resolution with root containment when in virtual_mode (sandboxed to cwd)
 * - Prevent symlink-following on file I/O using O_NOFOLLOW when available
 * - Ripgrep-powered grep with JSON parsing, plus regex fallback
 *   and optional glob include filtering, while preserving virtual path behavior
 */

import * as fs from "fs/promises";
import * as fsSync from "fs";
import * as path from "path";
import { spawn } from "child_process";
import fg from "fast-glob";
import micromatch from "micromatch";
import type {
  BackendProtocol,
  EditResult,
  FileInfo,
  GrepMatch,
  WriteResult,
} from "./protocol.js";
import {
  checkEmptyContent,
  formatContentWithLineNumbers,
  performStringReplacement,
} from "./utils.js";

const SUPPORTS_NOFOLLOW = fsSync.constants.O_NOFOLLOW !== undefined;

/**
 * Backend that reads and writes files directly from the filesystem.
 *
 * Files are accessed using their actual filesystem paths. Relative paths are
 * resolved relative to the current working directory. Content is read/written
 * as plain text, and metadata (timestamps) are derived from filesystem stats.
 */
export class FilesystemBackend implements BackendProtocol {
  private cwd: string;
  private virtualMode: boolean;
  private maxFileSizeBytes: number;

  constructor(
    options: {
      rootDir?: string;
      virtualMode?: boolean;
      maxFileSizeMb?: number;
    } = {},
  ) {
    const { rootDir, virtualMode = false, maxFileSizeMb = 10 } = options;
    this.cwd = rootDir ? path.resolve(rootDir) : process.cwd();
    this.virtualMode = virtualMode;
    this.maxFileSizeBytes = maxFileSizeMb * 1024 * 1024;
  }

  /**
   * Resolve a file path with security checks.
   *
   * When virtualMode=true, treat incoming paths as virtual absolute paths under
   * this.cwd, disallow traversal (.., ~) and ensure resolved path stays within root.
   * When virtualMode=false, preserve legacy behavior: absolute paths are allowed
   * as-is; relative paths resolve under cwd.
   *
   * @param key - File path (absolute, relative, or virtual when virtualMode=true)
   * @returns Resolved absolute path string
   * @throws Error if path traversal detected or path outside root
   */
  private resolvePath(key: string): string {
    if (this.virtualMode) {
      const vpath = key.startsWith("/") ? key : "/" + key;
      if (vpath.includes("..") || vpath.startsWith("~")) {
        throw new Error("Path traversal not allowed");
      }
      const full = path.resolve(this.cwd, vpath.substring(1));
      const relative = path.relative(this.cwd, full);
      if (relative.startsWith("..") || path.isAbsolute(relative)) {
        throw new Error(`Path: ${full} outside root directory: ${this.cwd}`);
      }
      return full;
    }

    if (path.isAbsolute(key)) {
      return key;
    }
    return path.resolve(this.cwd, key);
  }

  /**
   * List files and directories in the specified directory (non-recursive).
   *
   * @param dirPath - Absolute directory path to list files from
   * @returns List of FileInfo objects for files and directories directly in the directory.
   *          Directories have a trailing / in their path and is_dir=true.
   */
  async lsInfo(dirPath: string): Promise<FileInfo[]> {
    try {
      const resolvedPath = this.resolvePath(dirPath);
      const stat = await fs.stat(resolvedPath);

      if (!stat.isDirectory()) {
        return [];
      }

      const entries = await fs.readdir(resolvedPath, { withFileTypes: true });
      const results: FileInfo[] = [];

      const cwdStr = this.cwd.endsWith(path.sep)
        ? this.cwd
        : this.cwd + path.sep;

      for (const entry of entries) {
        const fullPath = path.join(resolvedPath, entry.name);

        try {
          const entryStat = await fs.stat(fullPath);
          const isFile = entryStat.isFile();
          const isDir = entryStat.isDirectory();

          if (!this.virtualMode) {
            // Non-virtual mode: use absolute paths
            if (isFile) {
              results.push({
                path: fullPath,
                is_dir: false,
                size: entryStat.size,
                modified_at: entryStat.mtime.toISOString(),
              });
            } else if (isDir) {
              results.push({
                path: fullPath + path.sep,
                is_dir: true,
                size: 0,
                modified_at: entryStat.mtime.toISOString(),
              });
            }
          } else {
            let relativePath: string;
            if (fullPath.startsWith(cwdStr)) {
              relativePath = fullPath.substring(cwdStr.length);
            } else if (fullPath.startsWith(this.cwd)) {
              relativePath = fullPath
                .substring(this.cwd.length)
                .replace(/^[/\\]/, "");
            } else {
              relativePath = fullPath;
            }

            relativePath = relativePath.split(path.sep).join("/");
            const virtPath = "/" + relativePath;

            if (isFile) {
              results.push({
                path: virtPath,
                is_dir: false,
                size: entryStat.size,
                modified_at: entryStat.mtime.toISOString(),
              });
            } else if (isDir) {
              results.push({
                path: virtPath + "/",
                is_dir: true,
                size: 0,
                modified_at: entryStat.mtime.toISOString(),
              });
            }
          }
        } catch {
          // Skip entries we can't stat
          continue;
        }
      }

      results.sort((a, b) => a.path.localeCompare(b.path));
      return results;
    } catch {
      return [];
    }
  }

  /**
   * Read file content with line numbers.
   *
   * @param filePath - Absolute or relative file path
   * @param offset - Line offset to start reading from (0-indexed)
   * @param limit - Maximum number of lines to read
   * @returns Formatted file content with line numbers, or error message
   */
  async read(
    filePath: string,
    offset: number = 0,
    limit: number = 2000,
  ): Promise<string> {
    try {
      const resolvedPath = this.resolvePath(filePath);

      let content: string;

      if (SUPPORTS_NOFOLLOW) {
        const stat = await fs.stat(resolvedPath);
        if (!stat.isFile()) {
          return `Error: File '${filePath}' not found`;
        }
        const fd = await fs.open(
          resolvedPath,
          fsSync.constants.O_RDONLY | fsSync.constants.O_NOFOLLOW,
        );
        try {
          content = await fd.readFile({ encoding: "utf-8" });
        } finally {
          await fd.close();
        }
      } else {
        const stat = await fs.lstat(resolvedPath);
        if (stat.isSymbolicLink()) {
          return `Error: Symlinks are not allowed: ${filePath}`;
        }
        if (!stat.isFile()) {
          return `Error: File '${filePath}' not found`;
        }
        content = await fs.readFile(resolvedPath, "utf-8");
      }

      const emptyMsg = checkEmptyContent(content);
      if (emptyMsg) {
        return emptyMsg;
      }

      const lines = content.split("\n");
      const startIdx = offset;
      const endIdx = Math.min(startIdx + limit, lines.length);

      if (startIdx >= lines.length) {
        return `Error: Line offset ${offset} exceeds file length (${lines.length} lines)`;
      }

      const selectedLines = lines.slice(startIdx, endIdx);
      return formatContentWithLineNumbers(selectedLines, startIdx + 1);
    } catch (e: any) {
      return `Error reading file '${filePath}': ${e.message}`;
    }
  }

  /**
   * Create a new file with content.
   * Returns WriteResult. External storage sets filesUpdate=null.
   */
  async write(filePath: string, content: string): Promise<WriteResult> {
    try {
      const resolvedPath = this.resolvePath(filePath);

      try {
        const stat = await fs.lstat(resolvedPath);
        if (stat.isSymbolicLink()) {
          return {
            error: `Cannot write to ${filePath} because it is a symlink. Symlinks are not allowed.`,
          };
        }
        return {
          error: `Cannot write to ${filePath} because it already exists. Read and then make an edit, or write to a new path.`,
        };
      } catch {
        // File doesn't exist, good to proceed
      }

      await fs.mkdir(path.dirname(resolvedPath), { recursive: true });

      if (SUPPORTS_NOFOLLOW) {
        const flags =
          fsSync.constants.O_WRONLY |
          fsSync.constants.O_CREAT |
          fsSync.constants.O_TRUNC |
          fsSync.constants.O_NOFOLLOW;

        const fd = await fs.open(resolvedPath, flags, 0o644);
        try {
          await fd.writeFile(content, "utf-8");
        } finally {
          await fd.close();
        }
      } else {
        await fs.writeFile(resolvedPath, content, "utf-8");
      }

      return { path: filePath, filesUpdate: null };
    } catch (e: any) {
      return { error: `Error writing file '${filePath}': ${e.message}` };
    }
  }

  /**
   * Edit a file by replacing string occurrences.
   * Returns EditResult. External storage sets filesUpdate=null.
   */
  async edit(
    filePath: string,
    oldString: string,
    newString: string,
    replaceAll: boolean = false,
  ): Promise<EditResult> {
    try {
      const resolvedPath = this.resolvePath(filePath);

      let content: string;

      if (SUPPORTS_NOFOLLOW) {
        const stat = await fs.stat(resolvedPath);
        if (!stat.isFile()) {
          return { error: `Error: File '${filePath}' not found` };
        }

        const fd = await fs.open(
          resolvedPath,
          fsSync.constants.O_RDONLY | fsSync.constants.O_NOFOLLOW,
        );
        try {
          content = await fd.readFile({ encoding: "utf-8" });
        } finally {
          await fd.close();
        }
      } else {
        const stat = await fs.lstat(resolvedPath);
        if (stat.isSymbolicLink()) {
          return { error: `Error: Symlinks are not allowed: ${filePath}` };
        }
        if (!stat.isFile()) {
          return { error: `Error: File '${filePath}' not found` };
        }
        content = await fs.readFile(resolvedPath, "utf-8");
      }

      const result = performStringReplacement(
        content,
        oldString,
        newString,
        replaceAll,
      );

      if (typeof result === "string") {
        return { error: result };
      }

      const [newContent, occurrences] = result;

      // Write securely
      if (SUPPORTS_NOFOLLOW) {
        const flags =
          fsSync.constants.O_WRONLY |
          fsSync.constants.O_TRUNC |
          fsSync.constants.O_NOFOLLOW;

        const fd = await fs.open(resolvedPath, flags);
        try {
          await fd.writeFile(newContent, "utf-8");
        } finally {
          await fd.close();
        }
      } else {
        await fs.writeFile(resolvedPath, newContent, "utf-8");
      }

      return { path: filePath, filesUpdate: null, occurrences: occurrences };
    } catch (e: any) {
      return { error: `Error editing file '${filePath}': ${e.message}` };
    }
  }

  /**
   * Structured search results or error string for invalid input.
   */
  async grepRaw(
    pattern: string,
    dirPath: string = "/",
    glob: string | null = null,
  ): Promise<GrepMatch[] | string> {
    // Validate regex
    try {
      new RegExp(pattern);
    } catch (e: any) {
      return `Invalid regex pattern: ${e.message}`;
    }

    // Resolve base path
    let baseFull: string;
    try {
      baseFull = this.resolvePath(dirPath || ".");
    } catch {
      return [];
    }

    try {
      await fs.stat(baseFull);
    } catch {
      return [];
    }

    // Try ripgrep first, fallback to regex search
    let results = await this.ripgrepSearch(pattern, baseFull, glob);
    if (results === null) {
      results = await this.pythonSearch(pattern, baseFull, glob);
    }

    const matches: GrepMatch[] = [];
    for (const [fpath, items] of Object.entries(results)) {
      for (const [lineNum, lineText] of items) {
        matches.push({ path: fpath, line: lineNum, text: lineText });
      }
    }
    return matches;
  }

  /**
   * Try to use ripgrep for fast searching.
   * Returns null if ripgrep is not available or fails.
   */
  private async ripgrepSearch(
    pattern: string,
    baseFull: string,
    includeGlob: string | null,
  ): Promise<Record<string, Array<[number, string]>> | null> {
    return new Promise((resolve) => {
      const args = ["--json"];
      if (includeGlob) {
        args.push("--glob", includeGlob);
      }
      args.push("--", pattern, baseFull);

      const proc = spawn("rg", args, { timeout: 30000 });
      const results: Record<string, Array<[number, string]>> = {};
      let output = "";

      proc.stdout.on("data", (data) => {
        output += data.toString();
      });

      proc.on("close", (code) => {
        if (code !== 0 && code !== 1) {
          // Error (code 1 means no matches, which is ok)
          resolve(null);
          return;
        }

        for (const line of output.split("\n")) {
          if (!line.trim()) continue;
          try {
            const data = JSON.parse(line);
            if (data.type !== "match") continue;

            const pdata = data.data || {};
            const ftext = pdata.path?.text;
            if (!ftext) continue;

            let virtPath: string;
            if (this.virtualMode) {
              try {
                const resolved = path.resolve(ftext);
                const relative = path.relative(this.cwd, resolved);
                if (relative.startsWith("..")) continue;
                const normalizedRelative = relative.split(path.sep).join("/");
                virtPath = "/" + normalizedRelative;
              } catch {
                continue;
              }
            } else {
              virtPath = ftext;
            }

            const ln = pdata.line_number;
            const lt = pdata.lines?.text?.replace(/\n$/, "") || "";
            if (ln === undefined) continue;

            if (!results[virtPath]) {
              results[virtPath] = [];
            }
            results[virtPath].push([ln, lt]);
          } catch {
            // Skip invalid JSON
            continue;
          }
        }

        resolve(results);
      });

      proc.on("error", () => {
        resolve(null);
      });
    });
  }

  /**
   * Fallback regex search implementation.
   */
  private async pythonSearch(
    pattern: string,
    baseFull: string,
    includeGlob: string | null,
  ): Promise<Record<string, Array<[number, string]>>> {
    let regex: RegExp;
    try {
      regex = new RegExp(pattern);
    } catch {
      return {};
    }

    const results: Record<string, Array<[number, string]>> = {};
    const stat = await fs.stat(baseFull);
    const root = stat.isDirectory() ? baseFull : path.dirname(baseFull);

    // Use fast-glob to recursively find all files
    const files = await fg("**/*", {
      cwd: root,
      absolute: true,
      onlyFiles: true,
      dot: true,
    });

    for (const fp of files) {
      try {
        // Filter by glob if provided
        if (
          includeGlob &&
          !micromatch.isMatch(path.basename(fp), includeGlob)
        ) {
          continue;
        }

        // Check file size
        const stat = await fs.stat(fp);
        if (stat.size > this.maxFileSizeBytes) {
          continue;
        }

        // Read and search
        const content = await fs.readFile(fp, "utf-8");
        const lines = content.split("\n");

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (regex.test(line)) {
            let virtPath: string;
            if (this.virtualMode) {
              try {
                const relative = path.relative(this.cwd, fp);
                if (relative.startsWith("..")) continue;
                const normalizedRelative = relative.split(path.sep).join("/");
                virtPath = "/" + normalizedRelative;
              } catch {
                continue;
              }
            } else {
              virtPath = fp;
            }

            if (!results[virtPath]) {
              results[virtPath] = [];
            }
            results[virtPath].push([i + 1, line]);
          }
        }
      } catch {
        // Skip files we can't read
        continue;
      }
    }

    return results;
  }

  /**
   * Structured glob matching returning FileInfo objects.
   */
  async globInfo(
    pattern: string,
    searchPath: string = "/",
  ): Promise<FileInfo[]> {
    if (pattern.startsWith("/")) {
      pattern = pattern.substring(1);
    }

    const resolvedSearchPath =
      searchPath === "/" ? this.cwd : this.resolvePath(searchPath);

    try {
      const stat = await fs.stat(resolvedSearchPath);
      if (!stat.isDirectory()) {
        return [];
      }
    } catch {
      return [];
    }

    const results: FileInfo[] = [];

    try {
      // Use fast-glob for pattern matching
      const matches = await fg(pattern, {
        cwd: resolvedSearchPath,
        absolute: true,
        onlyFiles: true,
        dot: true,
      });

      for (const matchedPath of matches) {
        try {
          const stat = await fs.stat(matchedPath);
          if (!stat.isFile()) continue;

          // Normalize fast-glob paths to platform separators
          // fast-glob returns forward slashes on all platforms, but we need
          // platform-native separators for path comparisons on Windows
          const normalizedPath = matchedPath.split("/").join(path.sep);

          if (!this.virtualMode) {
            results.push({
              path: normalizedPath,
              is_dir: false,
              size: stat.size,
              modified_at: stat.mtime.toISOString(),
            });
          } else {
            const cwdStr = this.cwd.endsWith(path.sep)
              ? this.cwd
              : this.cwd + path.sep;
            let relativePath: string;

            if (normalizedPath.startsWith(cwdStr)) {
              relativePath = normalizedPath.substring(cwdStr.length);
            } else if (normalizedPath.startsWith(this.cwd)) {
              relativePath = normalizedPath
                .substring(this.cwd.length)
                .replace(/^[/\\]/, "");
            } else {
              relativePath = normalizedPath;
            }

            relativePath = relativePath.split(path.sep).join("/");
            const virt = "/" + relativePath;
            results.push({
              path: virt,
              is_dir: false,
              size: stat.size,
              modified_at: stat.mtime.toISOString(),
            });
          }
        } catch {
          // Skip files we can't stat
          continue;
        }
      }
    } catch {
      // Ignore glob errors
    }

    results.sort((a, b) => a.path.localeCompare(b.path));
    return results;
  }
}</doc><doc title="Fs" desc="docs page.">/**
 * Middleware for providing filesystem tools to an agent.
 *
 * Provides ls, read_file, write_file, edit_file, glob, and grep tools with support for:
 * - Pluggable backends (StateBackend, StoreBackend, FilesystemBackend, CompositeBackend)
 * - Tool result eviction for large outputs
 */

import { createMiddleware, tool, ToolMessage } from "langchain";
import { Command, isCommand, getCurrentTaskInput } from "@langchain/langgraph";
import { z as z3 } from "zod/v3";
import { withLangGraph } from "@langchain/langgraph/zod";
import type {
  BackendProtocol,
  BackendFactory,
  FileData,
  StateAndStore,
} from "../backends/protocol.js";
import { StateBackend } from "../backends/state.js";
import { sanitizeToolCallId } from "../backends/utils.js";

/**
 * Zod v3 schema for FileData (re-export from backends)
 */
const FileDataSchema = z3.object({
  content: z3.array(z3.string()),
  created_at: z3.string(),
  modified_at: z3.string(),
});

export type { FileData };

/**
 * Merge file updates with support for deletions.
 */
function fileDataReducer(
  left: Record<string, FileData> | undefined,
  right: Record<string, FileData | null>,
): Record<string, FileData> {
  if (left === undefined) {
    const result: Record<string, FileData> = {};
    for (const [key, value] of Object.entries(right)) {
      if (value !== null) {
        result[key] = value;
      }
    }
    return result;
  }

  const result = { ...left };
  for (const [key, value] of Object.entries(right)) {
    if (value === null) {
      delete result[key];
    } else {
      result[key] = value;
    }
  }
  return result;
}

/**
 * Resolve backend from factory or instance.
 *
 * @param backend - Backend instance or factory function
 * @param stateAndStore - State and store container for backend initialization
 */
function getBackend(
  backend: BackendProtocol | BackendFactory,
  stateAndStore: StateAndStore,
): BackendProtocol {
  if (typeof backend === "function") {
    return backend(stateAndStore);
  }
  return backend;
}

/**
 * Helper to await if Promise, otherwise return value directly.
 */
async function awaitIfPromise<T>(value: T | Promise<T>): Promise<T> {
  return value;
}

// System prompts
const FILESYSTEM_SYSTEM_PROMPT = `You have access to a virtual filesystem. All file paths must start with a /.

- ls: list files in a directory (requires absolute path)
- read_file: read a file from the filesystem
- write_file: write to a file in the filesystem
- edit_file: edit a file in the filesystem
- glob: find files matching a pattern (e.g., "**/*.py")
- grep: search for text within files`;

// Tool descriptions
export const LS_TOOL_DESCRIPTION = "List files and directories in a directory";
export const READ_FILE_TOOL_DESCRIPTION = "Read the contents of a file";
export const WRITE_FILE_TOOL_DESCRIPTION =
  "Write content to a new file. Returns an error if the file already exists";
export const EDIT_FILE_TOOL_DESCRIPTION =
  "Edit a file by replacing a specific string with a new string";
export const GLOB_TOOL_DESCRIPTION =
  "Find files matching a glob pattern (e.g., '**/*.py' for all Python files)";
export const GREP_TOOL_DESCRIPTION =
  "Search for a regex pattern in files. Returns matching files and line numbers";

/**
 * Create ls tool using backend.
 */
function createLsTool(
  backend: BackendProtocol | BackendFactory,
  customDescription: string | null,
) {
  return tool(
    async (input, config) => {
      const stateAndStore: StateAndStore = {
        state: getCurrentTaskInput(config),
        store: (config as any).store,
      };
      const resolvedBackend = getBackend(backend, stateAndStore);
      const path = input.path || "/";
      const infos = await awaitIfPromise(resolvedBackend.lsInfo(path));

      if (infos.length === 0) {
        return `No files found in ${path}`;
      }

      // Format output
      const lines: string[] = [];
      for (const info of infos) {
        if (info.is_dir) {
          lines.push(`${info.path} (directory)`);
        } else {
          const size = info.size ? ` (${info.size} bytes)` : "";
          lines.push(`${info.path}${size}`);
        }
      }
      return lines.join("\n");
    },
    {
      name: "ls",
      description: customDescription || LS_TOOL_DESCRIPTION,
      schema: z3.object({
        path: z3
          .string()
          .optional()
          .default("/")
          .describe("Directory path to list (default: /)"),
      }),
    },
  );
}

/**
 * Create read_file tool using backend.
 */
function createReadFileTool(
  backend: BackendProtocol | BackendFactory,
  customDescription: string | null,
) {
  return tool(
    async (input, config) => {
      const stateAndStore: StateAndStore = {
        state: getCurrentTaskInput(config),
        store: (config as any).store,
      };
      const resolvedBackend = getBackend(backend, stateAndStore);
      const { file_path, offset = 0, limit = 2000 } = input;
      return await awaitIfPromise(
        resolvedBackend.read(file_path, offset, limit),
      );
    },
    {
      name: "read_file",
      description: customDescription || READ_FILE_TOOL_DESCRIPTION,
      schema: z3.object({
        file_path: z3.string().describe("Absolute path to the file to read"),
        offset: z3
          .number({ coerce: true })
          .optional()
          .default(0)
          .describe("Line offset to start reading from (0-indexed)"),
        limit: z3
          .number({ coerce: true })
          .optional()
          .default(2000)
          .describe("Maximum number of lines to read"),
      }),
    },
  );
}

/**
 * Create write_file tool using backend.
 */
function createWriteFileTool(
  backend: BackendProtocol | BackendFactory,
  customDescription: string | null,
) {
  return tool(
    async (input, config) => {
      const stateAndStore: StateAndStore = {
        state: getCurrentTaskInput(config),
        store: (config as any).store,
      };
      const resolvedBackend = getBackend(backend, stateAndStore);
      const { file_path, content } = input;
      const result = await awaitIfPromise(
        resolvedBackend.write(file_path, content),
      );

      if (result.error) {
        return result.error;
      }

      // If filesUpdate is present, return Command to update state
      if (result.filesUpdate) {
        return new Command({
          update: {
            files: result.filesUpdate,
            messages: [
              new ToolMessage({
                content: `Successfully wrote to '${file_path}'`,
                tool_call_id: config.toolCall?.id as string,
                name: "write_file",
              }),
            ],
          },
        });
      }

      // External storage (filesUpdate is null)
      return `Successfully wrote to '${file_path}'`;
    },
    {
      name: "write_file",
      description: customDescription || WRITE_FILE_TOOL_DESCRIPTION,
      schema: z3.object({
        file_path: z3.string().describe("Absolute path to the file to write"),
        content: z3.string().describe("Content to write to the file"),
      }),
    },
  );
}

/**
 * Create edit_file tool using backend.
 */
function createEditFileTool(
  backend: BackendProtocol | BackendFactory,
  customDescription: string | null,
) {
  return tool(
    async (input, config) => {
      const stateAndStore: StateAndStore = {
        state: getCurrentTaskInput(config),
        store: (config as any).store,
      };
      const resolvedBackend = getBackend(backend, stateAndStore);
      const { file_path, old_string, new_string, replace_all = false } = input;
      const result = await awaitIfPromise(
        resolvedBackend.edit(file_path, old_string, new_string, replace_all),
      );

      if (result.error) {
        return result.error;
      }

      const message = `Successfully replaced ${result.occurrences} occurrence(s) in '${file_path}'`;

      // If filesUpdate is present, return Command to update state
      if (result.filesUpdate) {
        return new Command({
          update: {
            files: result.filesUpdate,
            messages: [
              new ToolMessage({
                content: message,
                tool_call_id: config.toolCall?.id as string,
                name: "edit_file",
              }),
            ],
          },
        });
      }

      // External storage (filesUpdate is null)
      return message;
    },
    {
      name: "edit_file",
      description: customDescription || EDIT_FILE_TOOL_DESCRIPTION,
      schema: z3.object({
        file_path: z3.string().describe("Absolute path to the file to edit"),
        old_string: z3
          .string()
          .describe("String to be replaced (must match exactly)"),
        new_string: z3.string().describe("String to replace with"),
        replace_all: z3
          .boolean()
          .optional()
          .default(false)
          .describe("Whether to replace all occurrences"),
      }),
    },
  );
}

/**
 * Create glob tool using backend.
 */
function createGlobTool(
  backend: BackendProtocol | BackendFactory,
  customDescription: string | null,
) {
  return tool(
    async (input, config) => {
      const stateAndStore: StateAndStore = {
        state: getCurrentTaskInput(config),
        store: (config as any).store,
      };
      const resolvedBackend = getBackend(backend, stateAndStore);
      const { pattern, path = "/" } = input;
      const infos = await awaitIfPromise(
        resolvedBackend.globInfo(pattern, path),
      );

      if (infos.length === 0) {
        return `No files found matching pattern '${pattern}'`;
      }

      return infos.map((info) => info.path).join("\n");
    },
    {
      name: "glob",
      description: customDescription || GLOB_TOOL_DESCRIPTION,
      schema: z3.object({
        pattern: z3.string().describe("Glob pattern (e.g., '*.py', '**/*.ts')"),
        path: z3
          .string()
          .optional()
          .default("/")
          .describe("Base path to search from (default: /)"),
      }),
    },
  );
}

/**
 * Create grep tool using backend.
 */
function createGrepTool(
  backend: BackendProtocol | BackendFactory,
  customDescription: string | null,
) {
  return tool(
    async (input, config) => {
      const stateAndStore: StateAndStore = {
        state: getCurrentTaskInput(config),
        store: (config as any).store,
      };
      const resolvedBackend = getBackend(backend, stateAndStore);
      const { pattern, path = "/", glob = null } = input;
      const result = await awaitIfPromise(
        resolvedBackend.grepRaw(pattern, path, glob),
      );

      // If string, it's an error
      if (typeof result === "string") {
        return result;
      }

      if (result.length === 0) {
        return `No matches found for pattern '${pattern}'`;
      }

      // Format output: group by file
      const lines: string[] = [];
      let currentFile: string | null = null;
      for (const match of result) {
        if (match.path !== currentFile) {
          currentFile = match.path;
          lines.push(`\n${currentFile}:`);
        }
        lines.push(`  ${match.line}: ${match.text}`);
      }

      return lines.join("\n");
    },
    {
      name: "grep",
      description: customDescription || GREP_TOOL_DESCRIPTION,
      schema: z3.object({
        pattern: z3.string().describe("Regex pattern to search for"),
        path: z3
          .string()
          .optional()
          .default("/")
          .describe("Base path to search from (default: /)"),
        glob: z3
          .string()
          .optional()
          .nullable()
          .describe("Optional glob pattern to filter files (e.g., '*.py')"),
      }),
    },
  );
}

/**
 * Options for creating filesystem middleware.
 */
export interface FilesystemMiddlewareOptions {
  /** Backend instance or factory (default: StateBackend) */
  backend?: BackendProtocol | BackendFactory;
  /** Optional custom system prompt override */
  systemPrompt?: string | null;
  /** Optional custom tool descriptions override */
  customToolDescriptions?: Record<string, string> | null;
  /** Optional token limit before evicting a tool result to the filesystem (default: 20000 tokens, ~80KB) */
  toolTokenLimitBeforeEvict?: number | null;
}

/**
 * Create filesystem middleware with all tools and features.
 */
export function createFilesystemMiddleware(
  options: FilesystemMiddlewareOptions = {},
) {
  const {
    backend = (stateAndStore: StateAndStore) => new StateBackend(stateAndStore),
    systemPrompt: customSystemPrompt = null,
    customToolDescriptions = null,
    toolTokenLimitBeforeEvict = 20000,
  } = options;

  const systemPrompt = customSystemPrompt || FILESYSTEM_SYSTEM_PROMPT;

  const tools = [
    createLsTool(backend, customToolDescriptions?.ls ?? null),
    createReadFileTool(backend, customToolDescriptions?.read_file ?? null),
    createWriteFileTool(backend, customToolDescriptions?.write_file ?? null),
    createEditFileTool(backend, customToolDescriptions?.edit_file ?? null),
    createGlobTool(backend, customToolDescriptions?.glob ?? null),
    createGrepTool(backend, customToolDescriptions?.grep ?? null),
  ];

  const FilesystemStateSchema = z3.object({
    files: withLangGraph(z3.record(z3.string(), FileDataSchema).default({}), {
      reducer: {
        fn: fileDataReducer,
        schema: z3.record(z3.string(), FileDataSchema.nullable()),
      },
    }),
  });

  return createMiddleware({
    name: "FilesystemMiddleware",
    stateSchema: FilesystemStateSchema as any,
    tools,
    wrapModelCall: systemPrompt
      ? async (request, handler: any) => {
          const currentSystemPrompt = request.systemPrompt || "";
          const newSystemPrompt = currentSystemPrompt
            ? `${currentSystemPrompt}\n\n${systemPrompt}`
            : systemPrompt;
          return handler({ ...request, systemPrompt: newSystemPrompt });
        }
      : undefined,
    wrapToolCall: toolTokenLimitBeforeEvict
      ? ((async (request: any, handler: any) => {
          const result = await handler(request);

          async function processToolMessage(msg: ToolMessage) {
            if (
              typeof msg.content === "string" &&
              msg.content.length > toolTokenLimitBeforeEvict! * 4
            ) {
              // Build StateAndStore from request
              const stateAndStore: StateAndStore = {
                state: request.state || {},
                store: request.config?.store,
              };
              const resolvedBackend = getBackend(backend, stateAndStore);
              const sanitizedId = sanitizeToolCallId(
                request.toolCall?.id || msg.tool_call_id,
              );
              const evictPath = `/large_tool_results/${sanitizedId}`;

              const writeResult = await awaitIfPromise(
                resolvedBackend.write(evictPath, msg.content),
              );

              if (writeResult.error) {
                return { message: msg, filesUpdate: null };
              }

              const truncatedMessage = new ToolMessage({
                content: `Tool result too large (${Math.round(msg.content.length / 4)} tokens). Content saved to ${evictPath}`,
                tool_call_id: msg.tool_call_id,
                name: msg.name,
              });

              return {
                message: truncatedMessage,
                filesUpdate: writeResult.filesUpdate,
              };
            }
            return { message: msg, filesUpdate: null };
          }

          if (result instanceof ToolMessage) {
            const processed = await processToolMessage(result);

            if (processed.filesUpdate) {
              return new Command({
                update: {
                  files: processed.filesUpdate,
                  messages: [processed.message],
                },
              });
            }

            return processed.message;
          }

          if (isCommand(result)) {
            const update = result.update as any;
            if (!update?.messages) {
              return result;
            }

            let hasLargeResults = false;
            const accumulatedFiles: Record<string, FileData> = {
              ...(update.files || {}),
            };
            const processedMessages: ToolMessage[] = [];

            for (const msg of update.messages) {
              if (msg instanceof ToolMessage) {
                const processed = await processToolMessage(msg);
                processedMessages.push(processed.message);

                if (processed.filesUpdate) {
                  hasLargeResults = true;
                  Object.assign(accumulatedFiles, processed.filesUpdate);
                }
              } else {
                processedMessages.push(msg);
              }
            }

            if (hasLargeResults) {
              return new Command({
                update: {
                  ...update,
                  messages: processedMessages,
                  files: accumulatedFiles,
                },
              });
            }
          }

          return result;
        }) as any)
      : undefined,
  });
}</doc><doc title="Index" desc="docs page.">/**
 * Backends for pluggable file storage.
 *
 * Backends provide a uniform interface for file operations while allowing
 * different storage mechanisms (state, store, filesystem, database, etc.).
 */

export type {
  BackendProtocol,
  BackendFactory,
  FileData,
  FileInfo,
  GrepMatch,
  WriteResult,
  EditResult,
  StateAndStore,
} from "./protocol.js";

export { StateBackend } from "./state.js";
export { StoreBackend } from "./store.js";
export { FilesystemBackend } from "./filesystem.js";
export { CompositeBackend } from "./composite.js";

// Re-export utils for convenience
export * from "./utils.js";</doc><doc title="Index" desc="docs page.">export {
  createFilesystemMiddleware,
  type FilesystemMiddlewareOptions,
  type FileData,
} from "./fs.js";
export {
  createSubAgentMiddleware,
  type SubAgentMiddlewareOptions,
  type SubAgent,
} from "./subagents.js";
export { createPatchToolCallsMiddleware } from "./patch_tool_calls.js";</doc><doc title="Patch Tool Calls" desc="docs page.">import {
  createMiddleware,
  AgentMiddleware,
  ToolMessage,
  AIMessage,
} from "langchain";
import { RemoveMessage } from "@langchain/core/messages";
import { REMOVE_ALL_MESSAGES } from "@langchain/langgraph";

/**
 * Create middleware that patches dangling tool calls in the messages history.
 *
 * When an AI message contains tool_calls but subsequent messages don't include
 * the corresponding ToolMessage responses, this middleware adds synthetic
 * ToolMessages saying the tool call was cancelled.
 *
 * @returns AgentMiddleware that patches dangling tool calls
 *
 * @example
 * ```typescript
 * import { createAgent } from "langchain";
 * import { createPatchToolCallsMiddleware } from "./middleware/patch_tool_calls";
 *
 * const agent = createAgent({
 *   model: "claude-sonnet-4-5-20250929",
 *   middleware: [createPatchToolCallsMiddleware()],
 * });
 * ```
 */
export function createPatchToolCallsMiddleware(): AgentMiddleware {
  return createMiddleware({
    name: "patchToolCallsMiddleware",
    beforeAgent: async (state) => {
      const messages = state.messages;

      if (!messages || messages.length === 0) {
        return;
      }

      const patchedMessages: any[] = [];

      // Iterate over the messages and add any dangling tool calls
      for (let i = 0; i < messages.length; i++) {
        const msg = messages[i];
        patchedMessages.push(msg);

        // Check if this is an AI message with tool calls
        if (AIMessage.isInstance(msg) && msg.tool_calls != null) {
          for (const toolCall of msg.tool_calls) {
            // Look for a corresponding ToolMessage in the messages after this one
            const correspondingToolMsg = messages
              .slice(i)
              .find(
                (m) =>
                  ToolMessage.isInstance(m) && m.tool_call_id === toolCall.id,
              );

            if (!correspondingToolMsg) {
              // We have a dangling tool call which needs a ToolMessage
              const toolMsg = `Tool call ${toolCall.name} with id ${toolCall.id} was cancelled - another message came in before it could be completed.`;
              patchedMessages.push(
                new ToolMessage({
                  content: toolMsg,
                  name: toolCall.name,
                  tool_call_id: toolCall.id!,
                }),
              );
            }
          }
        }
      }

      // Return state update with RemoveMessage followed by patched messages
      return {
        messages: [
          new RemoveMessage({ id: REMOVE_ALL_MESSAGES }),
          ...patchedMessages,
        ],
      };
    },
  });
}</doc><doc title="Protocol" desc="docs page.">/**
 * Protocol definition for pluggable memory backends.
 *
 * This module defines the BackendProtocol that all backend implementations
 * must follow. Backends can store files in different locations (state, filesystem,
 * database, etc.) and provide a uniform interface for file operations.
 */

import type { BaseStore } from "@langchain/langgraph-checkpoint";

/**
 * Structured file listing info.
 *
 * Minimal contract used across backends. Only "path" is required.
 * Other fields are best-effort and may be absent depending on backend.
 */
export interface FileInfo {
  /** File path */
  path: string;
  /** Whether this is a directory */
  is_dir?: boolean;
  /** File size in bytes (approximate) */
  size?: number;
  /** ISO 8601 timestamp of last modification */
  modified_at?: string;
}

/**
 * Structured grep match entry.
 */
export interface GrepMatch {
  /** File path where match was found */
  path: string;
  /** Line number (1-indexed) */
  line: number;
  /** The matching line text */
  text: string;
}

/**
 * File data structure used by backends.
 *
 * All file data is represented as objects with this structure:
 */
export interface FileData {
  /** Lines of text content */
  content: string[];
  /** ISO format timestamp of creation */
  created_at: string;
  /** ISO format timestamp of last modification */
  modified_at: string;
}

/**
 * Result from backend write operations.
 *
 * Checkpoint backends populate filesUpdate with {file_path: file_data} for LangGraph state.
 * External backends set filesUpdate to null (already persisted to disk/S3/database/etc).
 */
export interface WriteResult {
  /** Error message on failure, undefined on success */
  error?: string;
  /** File path of written file, undefined on failure */
  path?: string;
  /**
   * State update dict for checkpoint backends, null for external storage.
   * Checkpoint backends populate this with {file_path: file_data} for LangGraph state.
   * External backends set null (already persisted to disk/S3/database/etc).
   */
  filesUpdate?: Record<string, FileData> | null;
}

/**
 * Result from backend edit operations.
 *
 * Checkpoint backends populate filesUpdate with {file_path: file_data} for LangGraph state.
 * External backends set filesUpdate to null (already persisted to disk/S3/database/etc).
 */
export interface EditResult {
  /** Error message on failure, undefined on success */
  error?: string;
  /** File path of edited file, undefined on failure */
  path?: string;
  /**
   * State update dict for checkpoint backends, null for external storage.
   * Checkpoint backends populate this with {file_path: file_data} for LangGraph state.
   * External backends set null (already persisted to disk/S3/database/etc).
   */
  filesUpdate?: Record<string, FileData> | null;
  /** Number of replacements made, undefined on failure */
  occurrences?: number;
}

/**
 * Protocol for pluggable memory backends (single, unified).
 *
 * Backends can store files in different locations (state, filesystem, database, etc.)
 * and provide a uniform interface for file operations.
 *
 * All file data is represented as objects with the FileData structure.
 *
 * Methods can return either direct values or Promises, allowing both
 * synchronous and asynchronous implementations.
 */
export interface BackendProtocol {
  /**
   * Structured listing with file metadata.
   *
   * Lists files and directories in the specified directory (non-recursive).
   * Directories have a trailing / in their path and is_dir=true.
   *
   * @param path - Absolute path to directory
   * @returns List of FileInfo objects for files and directories directly in the directory
   */
  lsInfo(path: string): FileInfo[] | Promise<FileInfo[]>;

  /**
   * Read file content with line numbers or an error string.
   *
   * @param filePath - Absolute file path
   * @param offset - Line offset to start reading from (0-indexed), default 0
   * @param limit - Maximum number of lines to read, default 2000
   * @returns Formatted file content with line numbers, or error message
   */
  read(
    filePath: string,
    offset?: number,
    limit?: number,
  ): string | Promise<string>;

  /**
   * Structured search results or error string for invalid input.
   *
   * Searches file contents for a regex pattern.
   *
   * @param pattern - Regex pattern to search for
   * @param path - Base path to search from (default: null)
   * @param glob - Optional glob pattern to filter files (e.g., "*.py")
   * @returns List of GrepMatch objects or error string for invalid regex
   */
  grepRaw(
    pattern: string,
    path?: string | null,
    glob?: string | null,
  ): GrepMatch[] | string | Promise<GrepMatch[] | string>;

  /**
   * Structured glob matching returning FileInfo objects.
   *
   * @param pattern - Glob pattern (e.g., `*.py`, `**\/*.ts`)
   * @param path - Base path to search from (default: "/")
   * @returns List of FileInfo objects matching the pattern
   */
  globInfo(pattern: string, path?: string): FileInfo[] | Promise<FileInfo[]>;

  /**
   * Create a new file.
   *
   * @param filePath - Absolute file path
   * @param content - File content as string
   * @returns WriteResult with error populated on failure
   */
  write(filePath: string, content: string): WriteResult | Promise<WriteResult>;

  /**
   * Edit a file by replacing string occurrences.
   *
   * @param filePath - Absolute file path
   * @param oldString - String to find and replace
   * @param newString - Replacement string
   * @param replaceAll - If true, replace all occurrences (default: false)
   * @returns EditResult with error, path, filesUpdate, and occurrences
   */
  edit(
    filePath: string,
    oldString: string,
    newString: string,
    replaceAll?: boolean,
  ): EditResult | Promise<EditResult>;
}

/**
 * State and store container for backend initialization.
 *
 * This provides a clean interface for what backends need to access:
 * - state: Current agent state (with files, messages, etc.)
 * - store: Optional persistent store for cross-conversation data
 *
 * Different contexts build this differently:
 * - Tools: Extract state via getCurrentTaskInput(config)
 * - Middleware: Use request.state directly
 */
export interface StateAndStore {
  /** Current agent state with files, messages, etc. */
  state: unknown;
  /** Optional BaseStore for persistent cross-conversation storage */
  store?: BaseStore;
  /** Optional assistant ID for per-assistant isolation in store */
  assistantId?: string;
}

/**
 * Factory function type for creating backend instances.
 *
 * Backends receive StateAndStore which contains the current state
 * and optional store, extracted from the execution context.
 *
 * @example
 * ```typescript
 * // Using in middleware
 * const middleware = createFilesystemMiddleware({
 *   backend: (stateAndStore) => new StateBackend(stateAndStore)
 * });
 * ```
 */
export type BackendFactory = (stateAndStore: StateAndStore) => BackendProtocol;</doc><doc title="State" desc="docs page.">/**
 * StateBackend: Store files in LangGraph agent state (ephemeral).
 */

import type {
  BackendProtocol,
  EditResult,
  FileData,
  FileInfo,
  GrepMatch,
  StateAndStore,
  WriteResult,
} from "./protocol.js";
import {
  createFileData,
  fileDataToString,
  formatReadResponse,
  globSearchFiles,
  grepMatchesFromFiles,
  performStringReplacement,
  updateFileData,
} from "./utils.js";

/**
 * Backend that stores files in agent state (ephemeral).
 *
 * Uses LangGraph's state management and checkpointing. Files persist within
 * a conversation thread but not across threads. State is automatically
 * checkpointed after each agent step.
 *
 * Special handling: Since LangGraph state must be updated via Command objects
 * (not direct mutation), operations return filesUpdate in WriteResult/EditResult
 * for the middleware to apply via Command.
 */
export class StateBackend implements BackendProtocol {
  private stateAndStore: StateAndStore;

  constructor(stateAndStore: StateAndStore) {
    this.stateAndStore = stateAndStore;
  }

  /**
   * Get files from current state.
   */
  private getFiles(): Record<string, FileData> {
    return (
      ((this.stateAndStore.state as any).files as Record<string, FileData>) ||
      {}
    );
  }

  /**
   * List files and directories in the specified directory (non-recursive).
   *
   * @param path - Absolute path to directory
   * @returns List of FileInfo objects for files and directories directly in the directory.
   *          Directories have a trailing / in their path and is_dir=true.
   */
  lsInfo(path: string): FileInfo[] {
    const files = this.getFiles();
    const infos: FileInfo[] = [];
    const subdirs = new Set<string>();

    // Normalize path to have trailing slash for proper prefix matching
    const normalizedPath = path.endsWith("/") ? path : path + "/";

    for (const [k, fd] of Object.entries(files)) {
      // Check if file is in the specified directory or a subdirectory
      if (!k.startsWith(normalizedPath)) {
        continue;
      }

      // Get the relative path after the directory
      const relative = k.substring(normalizedPath.length);

      // If relative path contains '/', it's in a subdirectory
      if (relative.includes("/")) {
        // Extract the immediate subdirectory name
        const subdirName = relative.split("/")[0];
        subdirs.add(normalizedPath + subdirName + "/");
        continue;
      }

      // This is a file directly in the current directory
      const size = fd.content.join("\n").length;
      infos.push({
        path: k,
        is_dir: false,
        size: size,
        modified_at: fd.modified_at,
      });
    }

    // Add directories to the results
    for (const subdir of Array.from(subdirs).sort()) {
      infos.push({
        path: subdir,
        is_dir: true,
        size: 0,
        modified_at: "",
      });
    }

    infos.sort((a, b) => a.path.localeCompare(b.path));
    return infos;
  }

  /**
   * Read file content with line numbers.
   *
   * @param filePath - Absolute file path
   * @param offset - Line offset to start reading from (0-indexed)
   * @param limit - Maximum number of lines to read
   * @returns Formatted file content with line numbers, or error message
   */
  read(filePath: string, offset: number = 0, limit: number = 2000): string {
    const files = this.getFiles();
    const fileData = files[filePath];

    if (!fileData) {
      return `Error: File '${filePath}' not found`;
    }

    return formatReadResponse(fileData, offset, limit);
  }

  /**
   * Create a new file with content.
   * Returns WriteResult with filesUpdate to update LangGraph state.
   */
  write(filePath: string, content: string): WriteResult {
    const files = this.getFiles();

    if (filePath in files) {
      return {
        error: `Cannot write to ${filePath} because it already exists. Read and then make an edit, or write to a new path.`,
      };
    }

    const newFileData = createFileData(content);
    return {
      path: filePath,
      filesUpdate: { [filePath]: newFileData },
    };
  }

  /**
   * Edit a file by replacing string occurrences.
   * Returns EditResult with filesUpdate and occurrences.
   */
  edit(
    filePath: string,
    oldString: string,
    newString: string,
    replaceAll: boolean = false,
  ): EditResult {
    const files = this.getFiles();
    const fileData = files[filePath];

    if (!fileData) {
      return { error: `Error: File '${filePath}' not found` };
    }

    const content = fileDataToString(fileData);
    const result = performStringReplacement(
      content,
      oldString,
      newString,
      replaceAll,
    );

    if (typeof result === "string") {
      return { error: result };
    }

    const [newContent, occurrences] = result;
    const newFileData = updateFileData(fileData, newContent);
    return {
      path: filePath,
      filesUpdate: { [filePath]: newFileData },
      occurrences: occurrences,
    };
  }

  /**
   * Structured search results or error string for invalid input.
   */
  grepRaw(
    pattern: string,
    path: string = "/",
    glob: string | null = null,
  ): GrepMatch[] | string {
    const files = this.getFiles();
    return grepMatchesFromFiles(files, pattern, path, glob);
  }

  /**
   * Structured glob matching returning FileInfo objects.
   */
  globInfo(pattern: string, path: string = "/"): FileInfo[] {
    const files = this.getFiles();
    const result = globSearchFiles(files, pattern, path);

    if (result === "No files found") {
      return [];
    }

    const paths = result.split("\n");
    const infos: FileInfo[] = [];
    for (const p of paths) {
      const fd = files[p];
      const size = fd ? fd.content.join("\n").length : 0;
      infos.push({
        path: p,
        is_dir: false,
        size: size,
        modified_at: fd?.modified_at || "",
      });
    }
    return infos;
  }
}</doc></src><tests><doc title="Utils" desc="docs page.">import { tool, createMiddleware } from "langchain";
import { ToolMessage } from "@langchain/core/messages";
import { Command } from "@langchain/langgraph";
import type { ReactAgent, StructuredTool } from "langchain";
import { z } from "zod/v3";
import { withLangGraph } from "@langchain/langgraph/zod";
/**
 * Assert that an agent has all the expected deep agent qualities
 */
export function assertAllDeepAgentQualities(
  agent: ReactAgent<any, any, any, any>
) {
  // Check state channels
  const channels = Object.keys(agent.graph?.channels || {});
  if (!channels.includes("todos")) {
    throw new Error(
      `Expected agent to have 'todos' channel, got: ${channels.join(", ")}`
    );
  }
  if (!channels.includes("files")) {
    throw new Error(
      `Expected agent to have 'files' channel, got: ${channels.join(", ")}`
    );
  }

  // Check tools
  const tools = (agent as any).graph?.nodes?.tools?.bound?.tools || [];
  const toolNames = tools.map((t: any) => t.name);

  const expectedTools = [
    "write_todos",
    "ls",
    "read_file",
    "write_file",
    "edit_file",
    "task",
  ];
  for (const toolName of expectedTools) {
    if (!toolNames.includes(toolName)) {
      throw new Error(
        `Expected agent to have '${toolName}' tool, got: ${toolNames.join(", ")}`
      );
    }
  }
}

/**
 * Constants
 */
export const SAMPLE_MODEL = "claude-sonnet-4-5-20250929";

/**
 * Mock tools for testing
 */

export const getPremierLeagueStandings = tool(
  async (_, config) => {
    const longToolMsg =
      "This is a long tool message that should be evicted to the filesystem.\n".repeat(
        300
      );
    return new Command({
      update: {
        messages: [
          new ToolMessage({
            content: longToolMsg,
            tool_call_id: config.toolCall?.id as string,
          }),
        ],
        files: {
          "/test.txt": {
            content: ["Goodbye world"],
            created_at: "2021-01-01",
            modified_at: "2021-01-01",
          },
        },
      },
    });
  },
  {
    name: "get_premier_league_standings",
    description: "Use this tool to get premier league standings",
    schema: z.object({}),
  }
);

export const getLaLigaStandings = tool(
  async (_, config) => {
    const longToolMsg =
      "This is a long tool message that should be evicted to the filesystem.\n".repeat(
        300
      );
    return new Command({
      update: {
        messages: [
          new ToolMessage({
            content: longToolMsg,
            tool_call_id: config.toolCall?.id as string,
          }),
        ],
      },
    });
  },
  {
    name: "get_la_liga_standings",
    description: "Use this tool to get la liga standings",
    schema: z.object({}),
  }
);

export const getNbaStandings = tool(
  () => {
    return "Sample text that is too long to fit in the token limit\n".repeat(
      10000
    );
  },
  {
    name: "get_nba_standings",
    description:
      "Use this tool to get a comprehensive report on the NBA standings",
    schema: z.object({}),
  }
);

export const getNflStandings = tool(
  () => {
    return "Sample text that is too long to fit in the token limit\n".repeat(
      100
    );
  },
  {
    name: "get_nfl_standings",
    description:
      "Use this tool to get a comprehensive report on the NFL standings",
    schema: z.object({}),
  }
);

export const getWeather = tool(
  (input) => `The weather in ${input.location} is sunny.`,
  {
    name: "get_weather",
    description: "Use this tool to get the weather",
    schema: z.object({ location: z.string() }),
  }
);

export const getSoccerScores = tool(
  (input) => `The latest soccer scores for ${input.team} are 2-1.`,
  {
    name: "get_soccer_scores",
    description: "Use this tool to get the latest soccer scores",
    schema: z.object({
      team: z.string(),
    }),
  }
);

export const sampleTool = tool((input) => input.sample_input, {
  name: "sample_tool",
  description: "Sample tool",
  schema: z.object({
    sample_input: z.string(),
  }),
});

export const TOY_BASKETBALL_RESEARCH =
  "Lebron James is the best basketball player of all time with over 40k points and 21 seasons in the NBA.";

export const researchBasketball = tool(
  async (input, config) => {
    const state = (config as any).state || {};
    const currentResearch = state.research || "";
    const research = `${currentResearch}\n\nResearching on ${input.topic}... Done! ${TOY_BASKETBALL_RESEARCH}`;
    return new Command({
      update: {
        research,
        messages: [
          new ToolMessage({
            content: research,
            tool_call_id: config.toolCall?.id as string,
          }),
        ],
      },
    });
  },
  {
    name: "research_basketball",
    description:
      "Use this tool to conduct research into basketball and save it to state",
    schema: z.object({ topic: z.string() }),
  }
);

/**
 * Middleware classes for testing
 */

// Research state
const ResearchStateSchema = z.object({
  research: withLangGraph(
    z.string().default(() => ""),
    {
      reducer: {
        fn: (left, right) => right || left || "",
        schema: z.string().nullable(),
      },
    }
  ),
});

export const ResearchMiddleware = createMiddleware({
  name: "ResearchMiddleware",
  stateSchema: ResearchStateSchema,
});

export const ResearchMiddlewareWithTools = createMiddleware({
  name: "ResearchMiddlewareWithTools",
  stateSchema: ResearchStateSchema,
  tools: [researchBasketball],
});

export const SampleMiddlewareWithTools = createMiddleware({
  name: "SampleMiddlewareWithTools",
  tools: [sampleTool],
});

// Sample state
const SampleStateSchema = z.object({
  sample_input: withLangGraph(
    z.string().default(() => ""),
    {
      reducer: {
        fn: (left, right) => right || left || "",
        schema: z.string().nullable(),
      },
    }
  ),
});

export const SampleMiddlewareWithToolsAndState = createMiddleware({
  name: "SampleMiddlewareWithToolsAndState",
  stateSchema: SampleStateSchema,
  tools: [sampleTool],
});

export const WeatherToolMiddleware = createMiddleware({
  name: "WeatherToolMiddleware",
  tools: [getWeather],
});

export function extractToolsFromAgent(agent: ReactAgent) {
  const graph = agent.graph;
  const toolsNode = graph.nodes?.tools.bound as unknown as {
    tools: StructuredTool[];
  };

  return Object.fromEntries(
    (toolsNode.tools ?? []).map((tool) => [tool.name, tool])
  );
}</doc><doc title="Deepagents.Test" desc="docs page.">import { describe, it, expect } from "vitest";
import { AIMessage, HumanMessage } from "@langchain/core/messages";
import { createDeepAgent } from "../../src/index.js";
import {
  SAMPLE_MODEL,
  TOY_BASKETBALL_RESEARCH,
  ResearchMiddleware,
  ResearchMiddlewareWithTools,
  SampleMiddlewareWithTools,
  SampleMiddlewareWithToolsAndState,
  WeatherToolMiddleware,
  assertAllDeepAgentQualities,
  getSoccerScores,
  getWeather,
  sampleTool,
  extractToolsFromAgent,
} from "../utils.js";

describe("DeepAgents Integration Tests", () => {
  it.concurrent("should create a base deep agent", () => {
    const agent = createDeepAgent();
    assertAllDeepAgentQualities(agent);
  });

  it.concurrent("should create deep agent with tool", () => {
    const agent = createDeepAgent({ tools: [sampleTool] });
    assertAllDeepAgentQualities(agent);

    const toolNames = Object.keys(extractToolsFromAgent(agent));
    expect(toolNames).toContain("sample_tool");
  });

  it.concurrent("should create deep agent with middleware with tool", () => {
    const agent = createDeepAgent({ middleware: [SampleMiddlewareWithTools] });
    assertAllDeepAgentQualities(agent);

    const toolNames = Object.keys(extractToolsFromAgent(agent));
    expect(toolNames).toContain("sample_tool");
  });

  it.concurrent(
    "should create deep agent with middleware with tool and state",
    () => {
      const agent = createDeepAgent({
        middleware: [SampleMiddlewareWithToolsAndState],
      });
      assertAllDeepAgentQualities(agent);

      const toolNames = Object.keys(extractToolsFromAgent(agent));
      expect(toolNames).toContain("sample_tool");

      expect(agent.graph.streamChannels).toContain("sample_input");
    }
  );

  it.concurrent(
    "should create deep agent with subagents",
    { timeout: 60000 },
    async () => {
      const subagents = [
        {
          name: "weather_agent",
          description: "Use this agent to get the weather",
          systemPrompt: "You are a weather agent.",
          tools: [getWeather],
          model: SAMPLE_MODEL,
        },
      ];
      const agent = createDeepAgent({ tools: [sampleTool], subagents });
      assertAllDeepAgentQualities(agent);

      const result = await agent.invoke({
        messages: [new HumanMessage("What is the weather in Tokyo?")],
      });

      const agentMessages = result.messages.filter((msg: any) =>
        AIMessage.isInstance(msg)
      );
      const toolCalls = agentMessages.flatMap(
        (msg: any) => msg.tool_calls || []
      );

      expect(
        toolCalls.some(
          (tc: any) =>
            tc.name === "task" && tc.args?.subagent_type === "weather_agent"
        )
      ).toBe(true);
    }
  );

  it.concurrent(
    "should create deep agent with subagents and general purpose",
    { timeout: 60000 },
    async () => {
      const subagents = [
        {
          name: "weather_agent",
          description: "Use this agent to get the weather",
          systemPrompt: "You are a weather agent.",
          tools: [getWeather],
          model: SAMPLE_MODEL,
        },
      ];
      const agent = createDeepAgent({ tools: [sampleTool], subagents });
      assertAllDeepAgentQualities(agent);

      const result = await agent.invoke({
        messages: [
          new HumanMessage(
            "Use the general purpose subagent to call the sample tool"
          ),
        ],
      });

      const agentMessages = result.messages.filter((msg: any) =>
        AIMessage.isInstance(msg)
      );
      const toolCalls = agentMessages.flatMap(
        (msg: any) => msg.tool_calls || []
      );

      expect(
        toolCalls.some(
          (tc: any) =>
            tc.name === "task" && tc.args?.subagent_type === "general-purpose"
        )
      ).toBe(true);
    }
  );

  it.concurrent(
    "should create deep agent with subagents with middleware",
    { timeout: 60000 },
    async () => {
      const subagents = [
        {
          name: "weather_agent",
          description: "Use this agent to get the weather",
          systemPrompt: "You are a weather agent.",
          tools: [],
          model: SAMPLE_MODEL,
          middleware: [WeatherToolMiddleware],
        },
      ];
      const agent = createDeepAgent({ tools: [sampleTool], subagents });
      assertAllDeepAgentQualities(agent);

      const result = await agent.invoke({
        messages: [new HumanMessage("What is the weather in Tokyo?")],
      });

      const agentMessages = result.messages.filter((msg: any) =>
        AIMessage.isInstance(msg)
      );
      const toolCalls = agentMessages.flatMap(
        (msg: any) => msg.tool_calls || []
      );

      expect(
        toolCalls.some(
          (tc: any) =>
            tc.name === "task" && tc.args?.subagent_type === "weather_agent"
        )
      ).toBe(true);
    }
  );

  it.concurrent(
    "should create deep agent with custom subagents",
    { timeout: 60000 },
    async () => {
      const agent = createDeepAgent({
        tools: [sampleTool],
        subagents: [
          {
            name: "weather_agent",
            description: "Use this agent to get the weather",
            systemPrompt: "You are a weather agent.",
            tools: [getWeather],
            model: SAMPLE_MODEL,
          },
          {
            name: "soccer_agent",
            description: "Use this agent to get the latest soccer scores",
            tools: [getSoccerScores],
            model: SAMPLE_MODEL,
            systemPrompt: "You are a soccer agent.",
          },
        ],
      });
      assertAllDeepAgentQualities(agent);

      const result = await agent.invoke({
        messages: [
          new HumanMessage(
            "Look up the weather in Tokyo, and the latest scores for Manchester City!"
          ),
        ],
      });

      const agentMessages = result.messages.filter((msg: any) =>
        AIMessage.isInstance(msg)
      );
      const toolCalls = agentMessages.flatMap(
        (msg: any) => msg.tool_calls || []
      );

      expect(
        toolCalls.some(
          (tc: any) =>
            tc.name === "task" && tc.args?.subagent_type === "weather_agent"
        )
      ).toBe(true);
      expect(
        toolCalls.some(
          (tc: any) =>
            tc.name === "task" && tc.args?.subagent_type === "soccer_agent"
        )
      ).toBe(true);
    }
  );

  it.concurrent(
    "should create deep agent with extended state and subagents",
    { timeout: 60000 },
    async () => {
      const subagents = [
        {
          name: "basketball_info_agent",
          description:
            "Use this agent to get surface level info on any basketball topic",
          systemPrompt: "You are a basketball info agent.",
          middleware: [ResearchMiddlewareWithTools],
        },
      ];
      const agent = createDeepAgent({
        tools: [sampleTool],
        subagents,
        middleware: [ResearchMiddleware],
      });
      assertAllDeepAgentQualities(agent);
      expect(agent.graph.streamChannels).toContain("research");

      const result = await agent.invoke(
        {
          messages: [
            new HumanMessage("Get surface level info on lebron james"),
          ],
        },
        { recursionLimit: 100 }
      );

      const agentMessages = result.messages.filter((msg: any) =>
        AIMessage.isInstance(msg)
      );
      const toolCalls = agentMessages.flatMap(
        (msg: any) => msg.tool_calls || []
      );

      expect(
        toolCalls.some(
          (tc: any) =>
            tc.name === "task" &&
            tc.args?.subagent_type === "basketball_info_agent"
        )
      ).toBe(true);
      expect(result.research).toContain(TOY_BASKETBALL_RESEARCH);
    }
  );

  it.concurrent(
    "should create deep agent with subagents no tools",
    { timeout: 60000 },
    async () => {
      const subagents = [
        {
          name: "basketball_info_agent",
          description:
            "Use this agent to get surface level info on any basketball topic",
          systemPrompt: "You are a basketball info agent.",
        },
      ];
      const agent = createDeepAgent({ tools: [sampleTool], subagents });
      assertAllDeepAgentQualities(agent);

      const result = await agent.invoke(
        {
          messages: [
            new HumanMessage(
              "Use the basketball info subagent to call the sample tool"
            ),
          ],
        },
        { recursionLimit: 100 }
      );

      const agentMessages = result.messages.filter((msg: any) =>
        AIMessage.isInstance(msg)
      );
      const toolCalls = agentMessages.flatMap(
        (msg: any) => msg.tool_calls || []
      );

      expect(
        toolCalls.some(
          (tc: any) =>
            tc.name === "task" &&
            tc.args?.subagent_type === "basketball_info_agent"
        )
      ).toBe(true);
    }
  );

  // Note: response_format with ToolStrategy is not yet available in LangChain TS v1
  // Skipping test_response_format_tool_strategy for now
});</doc><doc title="Filesystem.Test" desc="docs page.">import { describe, it, expect } from "vitest";
import { createAgent } from "langchain";
import { HumanMessage, ToolMessage } from "@langchain/core/messages";
import { InMemoryStore } from "@langchain/langgraph-checkpoint";
import { MemorySaver } from "@langchain/langgraph";
import { createDeepAgent } from "../../src/index.js";
import {
  createFilesystemMiddleware,
  WRITE_FILE_TOOL_DESCRIPTION,
} from "../../src/middleware/fs.js";
import {
  StateBackend,
  StoreBackend,
  CompositeBackend,
} from "../../src/backends/index.js";
import { v4 as uuidv4 } from "uuid";
import {
  SAMPLE_MODEL,
  getPremierLeagueStandings,
  getLaLigaStandings,
  getNbaStandings,
} from "../utils.js";

describe("Filesystem Middleware Integration Tests", () => {
  it.concurrent.each([
    { useComposite: false, label: "StateBackend" },
    { useComposite: true, label: "CompositeBackend" },
  ])(
    "should override filesystem system prompt ($label)",
    { timeout: 60000 },
    async ({ useComposite }) => {
      const checkpointer = useComposite ? new MemorySaver() : undefined;
      const store = useComposite ? new InMemoryStore() : undefined;

      const backend = useComposite
        ? (stateAndStore: any) =>
            new CompositeBackend(new StateBackend(stateAndStore), {
              "/memories/": new StoreBackend(stateAndStore),
            })
        : undefined; // Use default StateBackend

      const filesystemMiddleware = createFilesystemMiddleware({
        backend,
        systemPrompt:
          "In every single response, you must say the word 'pokemon'! You love it!",
      });

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [filesystemMiddleware],
        checkpointer,
        store,
      });

      const config = useComposite
        ? { configurable: { thread_id: uuidv4() } }
        : undefined;
      const response = await agent.invoke(
        {
          messages: [new HumanMessage("What do you like?")],
        },
        config,
      );

      const lastMessage = response.messages[response.messages.length - 1];
      expect(lastMessage.content.toString().toLowerCase()).toContain("pokemon");
    },
  );

  it.concurrent.each([
    { useComposite: false, label: "StateBackend" },
    { useComposite: true, label: "CompositeBackend" },
  ])(
    "should override filesystem tool descriptions ($label)",
    { timeout: 60000 },
    async ({ useComposite }) => {
      const checkpointer = useComposite ? new MemorySaver() : undefined;
      const store = useComposite ? new InMemoryStore() : undefined;

      const backend = useComposite
        ? (stateAndStore: any) =>
            new CompositeBackend(new StateBackend(stateAndStore), {
              "/memories/": new StoreBackend(stateAndStore),
            })
        : undefined;

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend,
            customToolDescriptions: {
              ls: "Charmander",
              read_file: "Bulbasaur",
              edit_file: "Squirtle",
            },
          }),
        ] as const,
        tools: [],
        checkpointer,
        store,
      });

      const toolsArray = (agent as any).graph?.nodes?.tools?.bound?.tools || [];
      const tools: Record<string, any> = {};
      for (const tool of toolsArray) {
        tools[tool.name] = tool;
      }

      expect(tools).toMatchObject({
        ls: { description: "Charmander" },
        read_file: { description: "Bulbasaur" },
        write_file: {
          description: WRITE_FILE_TOOL_DESCRIPTION,
        },
        edit_file: {
          description: "Squirtle",
        },
      });
    },
  );

  it.concurrent(
    "should list longterm memory files without path",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      await store.put(["filesystem"], "/test.txt", {
        content: ["Hello world"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });
      await store.put(["filesystem"], "/pokemon/charmander.txt", {
        content: ["Ember"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ] as const,
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [new HumanMessage("List all of your files")],
          files: {
            "/pizza.txt": {
              content: ["Hello world"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
            "/pokemon/squirtle.txt": {
              content: ["Splash"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
          },
        } as any,
        config,
      );

      const messages = response.messages;
      const lsMessage = messages.find(
        (msg) => ToolMessage.isInstance(msg) && msg.name === "ls",
      );

      expect(lsMessage).toBeDefined();
      const lsContent = lsMessage!.content.toString();
      expect(lsContent).toContain("/pizza.txt");
      expect(lsContent).toContain("/pokemon/");
      expect(lsContent).toContain("/memories/");
    },
  );

  it.concurrent(
    "should list longterm memory files with path filter",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      await store.put(["filesystem"], "/test.txt", {
        content: ["Hello world"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });
      await store.put(["filesystem"], "/pokemon/charmander.txt", {
        content: ["Ember"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ] as const,
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [new HumanMessage("List all files in /pokemon")],
          files: {
            "/pizza.txt": {
              content: ["Hello world"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
            "/pokemon/squirtle.txt": {
              content: ["Splash"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
          },
        } as any,
        config,
      );

      const messages = response.messages;
      const lsMessage = messages.find(
        (msg) => ToolMessage.isInstance(msg) && msg.name === "ls",
      );

      expect(lsMessage).toBeDefined();
      const lsContent = lsMessage!.content.toString();
      expect(lsContent).toContain("/pokemon/squirtle.txt");
      expect(lsContent).not.toContain("/memories/pokemon/charmander.txt");
      expect(lsContent).not.toContain("/pizza.txt");
    },
  );

  it.concurrent(
    "should read longterm memory local file",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ] as const,
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [new HumanMessage("Read the file /pizza.txt")],
          files: {
            "/pizza.txt": {
              content: ["Pepperoni is the best"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
          },
        } as any,
        config,
      );

      const messages = response.messages;
      const readMessage = messages.find(
        (msg: any) => msg._getType() === "tool" && msg.name === "read_file",
      );

      expect(readMessage).toBeDefined();
      expect(readMessage!.content.toString()).toContain(
        "Pepperoni is the best",
      );
    },
  );

  it.concurrent(
    "should read longterm memory store file",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      await store.put(["filesystem"], "/test.txt", {
        content: ["Hello from store"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ],
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [new HumanMessage("Read the file /memories/test.txt")],
        },
        config,
      );

      const messages = response.messages;
      const readMessage = messages.find(
        (msg: any) => msg._getType() === "tool" && msg.name === "read_file",
      );

      expect(readMessage).toBeDefined();
      expect(readMessage!.content.toString()).toContain("Hello from store");
    },
  );

  it.concurrent(
    "should write to longterm memory",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ],
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      await agent.invoke(
        {
          messages: [
            new HumanMessage(
              "Write 'persistent data' to /memories/persistent.txt",
            ),
          ],
        },
        config,
      );

      // Verify file was written to store
      const items = await store.search(["filesystem"]);
      const persistentFile = items.find(
        (item) => item.key === "/persistent.txt",
      );

      expect(persistentFile).toBeDefined();
      expect((persistentFile!.value as any).content).toContain(
        "persistent data",
      );
    },
  );

  it.concurrent(
    "should fail to write to existing store file",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      await store.put(["filesystem"], "/existing.txt", {
        content: ["Already exists"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ],
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [
            new HumanMessage("Write 'new data' to /memories/existing.txt"),
          ],
        },
        config,
      );

      const messages = response.messages;
      const writeMessage = messages.find(
        (msg: any) => msg._getType() === "tool" && msg.name === "write_file",
      );

      expect(writeMessage).toBeDefined();
      expect(writeMessage!.content.toString()).toContain("already exists");
    },
  );

  it.concurrent(
    "should edit longterm memory file",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      await store.put(["filesystem"], "/editable.txt", {
        content: ["Line 1", "Line 2", "Line 3"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ],
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      await agent.invoke(
        {
          messages: [
            new HumanMessage(
              "Edit /memories/editable.txt: replace 'Line 2' with 'Modified Line 2'",
            ),
          ],
        },
        config,
      );

      // Verify file was edited in store
      const items = await store.search(["filesystem"]);
      const editedFile = items.find((item) => item.key === "/editable.txt");

      expect(editedFile).toBeDefined();
      expect((editedFile!.value as any).content).toContain("Modified Line 2");
    },
  );

  it.concurrent(
    "should handle tool results exceeding token limit",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      const agent = createAgent({
        model: SAMPLE_MODEL,
        tools: [getNbaStandings],
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ],
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [new HumanMessage("Get NBA standings")],
        },
        config,
      );

      const files = (response as any).files || {};
      const largeResultFiles = Object.keys(files).filter((f) =>
        f.includes("/large_tool_results/"),
      );

      expect(largeResultFiles.length).toBeGreaterThan(0);
    },
  );

  it.concurrent(
    "should handle tool results with custom token limit",
    { timeout: 120000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      const agent = createAgent({
        model: SAMPLE_MODEL,
        tools: [getNbaStandings],
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
            toolTokenLimitBeforeEvict: 10000, // Low limit to trigger eviction
          }),
        ],
        checkpointer,
        store,
      });

      const config = {
        configurable: { thread_id: uuidv4() },
        recursionLimit: 1000,
      };
      const response = await agent.invoke(
        {
          messages: [
            new HumanMessage(
              "Get NBA standings, if the information from the tool is not good, then just return, only try reading file 1 time max.",
            ),
          ],
        },
        config,
      );

      // Check if result was evicted with custom limit
      const files = (response as any).files || {};
      const largeResultFiles = Object.keys(files).filter((f) =>
        f.includes("/large_tool_results/"),
      );

      expect(largeResultFiles.length).toBeGreaterThan(0);
    },
  );

  it.concurrent(
    "should handle Command return with tool call",
    { timeout: 60000 },
    async () => {
      const agent = createDeepAgent({
        tools: [getPremierLeagueStandings],
        model: SAMPLE_MODEL,
      });

      const response = await agent.invoke({
        messages: [new HumanMessage("Get premier league standings")],
      });

      // Command returns files and research state
      expect(response.files).toBeDefined();
      expect(response.files["/test.txt"]).toBeDefined();
    },
  );

  it.concurrent(
    "should handle Command with existing state",
    { timeout: 60000 },
    async () => {
      const agent = createDeepAgent({
        tools: [getLaLigaStandings],
        model: SAMPLE_MODEL,
      });

      const response = await agent.invoke({
        messages: [new HumanMessage("Get la liga standings")],
        files: {
          "/existing.txt": {
            content: ["Existing file"],
            created_at: "2021-01-01",
            modified_at: "2021-01-01",
          },
        },
      });

      // Existing files should be preserved
      expect(response.files["/existing.txt"]).toBeDefined();
      expect(response.files["/existing.txt"].content).toContain(
        "Existing file",
      );
    },
  );

  it.concurrent(
    "should fail to write to existing local file",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ],
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [new HumanMessage("Write 'new content' to /existing.txt")],
          files: {
            "/existing.txt": {
              content: ["Already exists"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
          },
        } as any,
        config,
      );

      const messages = response.messages;
      const writeMessage = messages.find(
        (msg: any) => msg._getType() === "tool" && msg.name === "write_file",
      );

      expect(writeMessage).toBeDefined();
      expect(writeMessage!.content.toString()).toContain("already exists");
    },
  );

  it.concurrent(
    "should perform glob search in shortterm memory only",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [createFilesystemMiddleware()],
        checkpointer,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [new HumanMessage("Use glob to find all Python files")],
          files: {
            "/test.py": {
              content: ["import os"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
            "/main.py": {
              content: ["def main(): pass"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
            "/readme.txt": {
              content: ["Documentation"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
          },
        } as any,
        config,
      );

      const messages = response.messages;
      const globMessage = messages.find(
        (msg) => ToolMessage.isInstance(msg) && msg.name === "glob",
      );

      expect(globMessage).toBeDefined();
      const globContent = globMessage!.content.toString();
      expect(globContent).toContain("/test.py");
      expect(globContent).toContain("/main.py");
      expect(globContent).not.toContain("/readme.txt");
    },
  );

  it.concurrent(
    "should perform glob search in longterm memory only",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      await store.put(["filesystem"], "/config.py", {
        content: ["DEBUG = True"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });
      await store.put(["filesystem"], "/settings.py", {
        content: ["SECRET_KEY = 'abc'"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });
      await store.put(["filesystem"], "/notes.txt", {
        content: ["Important notes"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ],
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [
            new HumanMessage("Use glob to find all Python files in /memories"),
          ],
          files: {},
        } as any,
        config,
      );

      const messages = response.messages;
      const globMessage = messages.find(
        (msg) => ToolMessage.isInstance(msg) && msg.name === "glob",
      );

      expect(globMessage).toBeDefined();
      const globContent = globMessage!.content.toString();
      expect(globContent).toContain("/memories/config.py");
      expect(globContent).toContain("/memories/settings.py");
      expect(globContent).not.toContain("/memories/notes.txt");
    },
  );

  it.concurrent(
    "should perform glob search across mixed memory",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      await store.put(["filesystem"], "/longterm.py", {
        content: ["# Longterm file"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });
      await store.put(["filesystem"], "/longterm.txt", {
        content: ["Text file"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ],
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [new HumanMessage("Use glob to find all Python files")],
          files: {
            "/shortterm.py": {
              content: ["# Shortterm file"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
            "/shortterm.txt": {
              content: ["Another text file"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
          },
        } as any,
        config,
      );

      const messages = response.messages;
      const globMessage = messages.find(
        (msg) => ToolMessage.isInstance(msg) && msg.name === "glob",
      );

      expect(globMessage).toBeDefined();
      const globContent = globMessage!.content.toString();
      expect(globContent).toContain("/shortterm.py");
      expect(globContent).toContain("/memories/longterm.py");
      expect(globContent).not.toContain("/shortterm.txt");
      expect(globContent).not.toContain("/memories/longterm.txt");
    },
  );

  it.concurrent(
    "should perform grep search in shortterm memory only",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [createFilesystemMiddleware()],
        checkpointer,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [
            new HumanMessage(
              "Use grep to find all files containing the word 'import'",
            ),
          ],
          files: {
            "/test.py": {
              content: ["import os", "import sys"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
            "/main.py": {
              content: ["def main(): pass"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
            "/helper.py": {
              content: ["import json"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
          },
        } as any,
        config,
      );

      const messages = response.messages;
      const grepMessage = messages.find(
        (msg) => ToolMessage.isInstance(msg) && msg.name === "grep",
      );

      expect(grepMessage).toBeDefined();
      const grepContent = grepMessage!.content.toString();
      expect(grepContent).toContain("/test.py");
      expect(grepContent).toContain("/helper.py");
      expect(grepContent).not.toContain("/main.py");
    },
  );

  it.concurrent(
    "should perform grep search in longterm memory only",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      await store.put(["filesystem"], "/pokemon/charmander.txt", {
        content: ["Charmander is a fire type", "It evolves into Charmeleon"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });
      await store.put(["filesystem"], "/pokemon/squirtle.txt", {
        content: ["Squirtle is a water type", "It evolves into Wartortle"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });
      await store.put(["filesystem"], "/pokemon/bulbasaur.txt", {
        content: ["Bulbasaur is a grass type"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ],
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [
            new HumanMessage(
              "Use grep to find all files in the memories directory containing the word 'fire'",
            ),
          ],
          files: {},
        } as any,
        config,
      );

      const messages = response.messages;
      const grepMessage = messages.find(
        (msg) => ToolMessage.isInstance(msg) && msg.name === "grep",
      );

      expect(grepMessage).toBeDefined();
      const grepContent = grepMessage!.content.toString();
      expect(grepContent).toContain("/memories/pokemon/charmander.txt");
      expect(grepContent).not.toContain("/memories/pokemon/squirtle.txt");
      expect(grepContent).not.toContain("/memories/pokemon/bulbasaur.txt");
    },
  );

  it.concurrent(
    "should perform grep search across mixed memory",
    { timeout: 60000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      await store.put(["filesystem"], "/longterm_config.py", {
        content: ["DEBUG = True", "TESTING = False"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });
      await store.put(["filesystem"], "/longterm_settings.py", {
        content: ["SECRET_KEY = 'abc'"],
        created_at: "2021-01-01",
        modified_at: "2021-01-01",
      });

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [
          createFilesystemMiddleware({
            backend: (stateAndStore: any) =>
              new CompositeBackend(new StateBackend(stateAndStore), {
                "/memories/": new StoreBackend(stateAndStore),
              }),
          }),
        ],
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const response = await agent.invoke(
        {
          messages: [
            new HumanMessage("Use grep to find all files containing 'DEBUG'"),
          ],
          files: {
            "/shortterm_config.py": {
              content: ["DEBUG = False", "VERBOSE = True"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
            "/shortterm_main.py": {
              content: ["def main(): pass"],
              created_at: "2021-01-01",
              modified_at: "2021-01-01",
            },
          },
        } as any,
        config,
      );

      const messages = response.messages;
      const grepMessage = messages.find(
        (msg) => ToolMessage.isInstance(msg) && msg.name === "grep",
      );

      expect(grepMessage).toBeDefined();
      const grepContent = grepMessage!.content.toString();
      expect(grepContent).toContain("/shortterm_config.py");
      expect(grepContent).toContain("/memories/longterm_config.py");
      expect(grepContent).not.toContain("/shortterm_main.py");
      expect(grepContent).not.toContain("/memories/longterm_settings.py");
    },
  );

  it.concurrent(
    "should use default backend when no backend specified",
    { timeout: 120000 },
    async () => {
      const checkpointer = new MemorySaver();

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [createFilesystemMiddleware()],
        checkpointer,
      });

      const config = { configurable: { thread_id: uuidv4() } };

      const response = await agent.invoke(
        {
          messages: [new HumanMessage("Write 'Hello World' to /test.txt")],
        },
        config,
      );

      expect((response as any).files).toBeDefined();
      expect((response as any).files["/test.txt"]).toBeDefined();
      expect((response as any).files["/test.txt"].content).toContain(
        "Hello World",
      );

      const response2 = await agent.invoke(
        {
          messages: [new HumanMessage("Read /test.txt")],
        },
        config,
      );

      const messages = response2.messages;
      const readMessage = messages.find(
        (msg: any) => msg._getType() === "tool" && msg.name === "read_file",
      );
      expect(readMessage).toBeDefined();
      expect(readMessage!.content.toString()).toContain("Hello World");
    },
  );

  it.concurrent(
    "should handle longterm memory CRUD across multiple threads",
    { timeout: 120000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      // Pre-populate the store with a test file
      await store.put(["filesystem"], "/pokemon.txt", {
        content: ["Charmander is a fire-type Pokemon"],
        created_at: new Date().toISOString(),
        modified_at: new Date().toISOString(),
      });

      const agent = createDeepAgent({
        backend: (stateAndStore: any) =>
          new CompositeBackend(new StateBackend(stateAndStore), {
            "/memories/": new StoreBackend(stateAndStore),
          }),
        checkpointer,
        store,
      });

      // Read from one thread
      const config1 = { configurable: { thread_id: uuidv4() } };
      const readResponse = await agent.invoke(
        {
          messages: [new HumanMessage("Read /memories/pokemon.txt")],
        },
        config1,
      );

      const readMessages = readResponse.messages;
      const readMessage = readMessages.find(
        (msg: any) => msg._getType() === "tool" && msg.name === "read_file",
      );
      expect(readMessage).toBeDefined();
      expect(readMessage!.content.toString()).toContain("Charmander");

      // List from another thread
      const config2 = { configurable: { thread_id: uuidv4() } };
      const listResponse = await agent.invoke(
        {
          messages: [new HumanMessage("List files in /memories")],
        },
        config2,
      );

      const listMessages = listResponse.messages;
      const lsMessage = listMessages.find(
        (msg: any) => msg._getType() === "tool" && msg.name === "ls",
      );
      expect(lsMessage).toBeDefined();
      expect(lsMessage!.content.toString()).toContain("/memories/pokemon.txt");

      // Edit from yet another thread
      const config3 = { configurable: { thread_id: uuidv4() } };
      const editResponse = await agent.invoke(
        {
          messages: [
            new HumanMessage(
              "Edit /memories/pokemon.txt: replace 'fire' with 'blazing'",
            ),
          ],
        },
        config3,
      );

      const editMessages = editResponse.messages;
      const editMessage = editMessages.find(
        (msg: any) => msg._getType() === "tool" && msg.name === "edit_file",
      );
      expect(editMessage).toBeDefined();

      // Verify the edit persisted in the store
      const updatedFile = await store.get(["filesystem"], "/pokemon.txt");
      expect(updatedFile).toBeDefined();
      const content = (updatedFile!.value as any).content.join("\n");
      expect(content).toContain("blazing");
    },
  );

  it.concurrent(
    "should handle shortterm memory CRUD in single thread",
    { timeout: 120000 },
    async () => {
      const checkpointer = new MemorySaver();
      const store = new InMemoryStore();

      const agent = createDeepAgent({
        backend: (stateAndStore: any) => new StateBackend(stateAndStore),
        checkpointer,
        store,
      });

      const config = { configurable: { thread_id: uuidv4() } };

      // Write a shortterm memory file
      const writeResponse = await agent.invoke(
        {
          messages: [
            new HumanMessage(
              "Write a haiku about Charmander to /charmander.txt, use the word 'fiery'",
            ),
          ],
        },
        config,
      );

      const files = writeResponse.files || {};
      expect(files["/charmander.txt"]).toBeDefined();

      // Read the shortterm memory file
      const readResponse = await agent.invoke(
        {
          messages: [
            new HumanMessage(
              "Read the haiku about Charmander from /charmander.txt",
            ),
          ],
        },
        config,
      );

      const readMessages = readResponse.messages;
      const readMessage = [...readMessages]
        .reverse()
        .find(
          (msg: any) => msg._getType() === "tool" && msg.name === "read_file",
        );
      expect(readMessage).toBeDefined();
      expect(
        readMessage!.content.toString().toLowerCase().includes("fiery"),
      ).toBe(true);

      // List all files in shortterm memory
      const listResponse = await agent.invoke(
        {
          messages: [
            new HumanMessage("List all of the files in your filesystem"),
          ],
        },
        config,
      );

      const listMessages = listResponse.messages;
      const lsMessage = listMessages.find(
        (msg: any) => msg._getType() === "tool" && msg.name === "ls",
      );
      expect(lsMessage).toBeDefined();
      expect(lsMessage!.content.toString()).toContain("/charmander.txt");

      // Edit the shortterm memory file
      const editResponse = await agent.invoke(
        {
          messages: [
            new HumanMessage(
              "Edit the haiku about Charmander to use the word 'ember'",
            ),
          ],
        },
        config,
      );

      const editedFiles = editResponse.files || {};
      expect(editedFiles["/charmander.txt"]).toBeDefined();
      const content = editedFiles["/charmander.txt"].content.join("\n");
      expect(content.toLowerCase().includes("ember")).toBe(true);

      // Read again to verify edit
      const verifyResponse = await agent.invoke(
        {
          messages: [
            new HumanMessage(
              "Read the haiku about Charmander at /charmander.txt",
            ),
          ],
        },
        config,
      );

      const verifyMessages = verifyResponse.messages;
      const verifyReadMessage = [...verifyMessages]
        .reverse()
        .find(
          (msg: any) => msg._getType() === "tool" && msg.name === "read_file",
        );
      expect(verifyReadMessage).toBeDefined();
      expect(
        verifyReadMessage!.content.toString().toLowerCase().includes("ember"),
      ).toBe(true);
    },
  );
});</doc><doc title="Hitl.Test" desc="docs page.">import { describe, it, expect } from "vitest";
import { MemorySaver, Command } from "@langchain/langgraph";
import { v4 as uuidv4 } from "uuid";
import { createDeepAgent } from "../../src/index.js";
import {
  assertAllDeepAgentQualities,
  sampleTool,
  getWeather,
  getSoccerScores,
} from "../utils.js";
import {
  AIMessage,
  HITLRequest,
  HITLResponse,
  HumanMessage,
  Interrupt,
  ToolMessage,
  type InterruptOnConfig,
  createAgent,
  tool,
  humanInTheLoopMiddleware,
} from "langchain";
import { z } from "zod/v3";
import { SAMPLE_MODEL } from "../utils.js";

const SAMPLE_TOOL_CONFIG: Record<string, boolean | InterruptOnConfig> = {
  sample_tool: true,
  get_weather: false,
  get_soccer_scores: { allowedDecisions: ["approve", "reject"] },
};

describe("Human-in-the-Loop (HITL) Integration Tests", () => {
  it.concurrent(
    "should interrupt agent execution for tool approval",
    { timeout: 120000 },
    async () => {
      const checkpointer = new MemorySaver();
      const agent = createDeepAgent({
        tools: [sampleTool, getWeather, getSoccerScores],
        interruptOn: SAMPLE_TOOL_CONFIG,
        checkpointer,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      assertAllDeepAgentQualities(agent);

      // First invocation - should interrupt
      const result = await agent.invoke(
        {
          messages: [
            {
              role: "user",
              content:
                "Call the sample tool, get the weather in New York and get scores for the latest soccer games in parallel",
            },
          ],
        },
        config,
      );

      // Check tool calls were made
      const agentMessages = result.messages.filter((msg: any) =>
        AIMessage.isInstance(msg),
      );
      const toolCalls = agentMessages.flatMap(
        (msg: any) => msg.tool_calls || [],
      );

      expect(toolCalls.some((tc: any) => tc.name === "sample_tool")).toBe(true);
      expect(toolCalls.some((tc: any) => tc.name === "get_weather")).toBe(true);
      expect(toolCalls.some((tc: any) => tc.name === "get_soccer_scores")).toBe(
        true,
      );

      // Check interrupts
      expect(result.__interrupt__).toBeDefined();
      expect(result.__interrupt__).toHaveLength(1);

      const interrupts = result.__interrupt__[0].value as HITLRequest;
      const actionRequests = interrupts.actionRequests;

      expect(actionRequests).toHaveLength(2);
      expect(actionRequests.some((ar: any) => ar.name === "sample_tool")).toBe(
        true,
      );
      expect(
        actionRequests.some((ar: any) => ar.name === "get_soccer_scores"),
      ).toBe(true);

      // Check review configs
      const reviewConfigs = interrupts.reviewConfigs;
      expect(
        reviewConfigs.some(
          (rc) =>
            rc.actionName === "sample_tool" &&
            rc.allowedDecisions.includes("approve") &&
            rc.allowedDecisions.includes("edit") &&
            rc.allowedDecisions.includes("reject"),
        ),
      ).toBe(true);
      expect(
        reviewConfigs.some(
          (rc) =>
            rc.actionName === "get_soccer_scores" &&
            rc.allowedDecisions.includes("approve") &&
            rc.allowedDecisions.includes("reject"),
        ),
      ).toBe(true);

      // Resume with approvals
      const result2 = await agent.invoke(
        new Command({
          resume: {
            decisions: [{ type: "approve" }, { type: "approve" }],
          },
        }),
        config,
      );

      // Check tool results are present
      const toolResults = result2.messages.filter(
        (msg: any) => msg._getType() === "tool",
      );
      expect(toolResults.some((tr: any) => tr.name === "sample_tool")).toBe(
        true,
      );
      expect(toolResults.some((tr: any) => tr.name === "get_weather")).toBe(
        true,
      );
      expect(
        toolResults.some((tr: any) => tr.name === "get_soccer_scores"),
      ).toBe(true);

      // No more interrupts
      expect(result2.__interrupt__).toBeUndefined();
    },
  );

  it.concurrent(
    "should handle HITL with subagents",
    { timeout: 120000 },
    async () => {
      const checkpointer = new MemorySaver();
      const agent = createDeepAgent({
        tools: [sampleTool, getWeather, getSoccerScores],
        interruptOn: SAMPLE_TOOL_CONFIG,
        checkpointer,
      });

      const config = { configurable: { thread_id: uuidv4() } };
      assertAllDeepAgentQualities(agent);

      // First invocation - use subagent which should also interrupt
      const result = await agent.invoke(
        {
          messages: [
            {
              role: "user",
              content:
                "Use the task tool to kick off the general-purpose subagent. Tell it to call the sample tool, get the weather in New York and get scores for the latest soccer games in parallel",
            },
          ],
        },
        config,
      );

      // Check that task tool was called
      const agentMessages = result.messages.filter(
        (msg: any) => msg._getType() === "ai",
      );
      const toolCalls = agentMessages.flatMap(
        (msg: any) => msg.tool_calls || [],
      );
      expect(toolCalls.some((tc: any) => tc.name === "task")).toBe(true);

      // Subagent should have interrupts too
      expect(result.__interrupt__).toBeDefined();

      // Resume with approvals
      const toolResultNames: string[] = [];

      for await (const chunk of await agent.graph.stream(
        new Command({
          resume: { decisions: [{ type: "approve" }, { type: "approve" }] },
        }),
        {
          ...config,
          streamMode: ["updates"],
          subgraphs: true,
        },
      )) {
        const update = chunk[2] ?? {};
        if (!("tools" in update)) continue;

        const tools = update.tools as { messages: ToolMessage[] };
        toolResultNames.push(...tools.messages.map((msg: any) => msg.name));
      }

      expect(toolResultNames).toContain("sample_tool");
      expect(toolResultNames).toContain("get_weather");
      expect(toolResultNames).toContain("get_soccer_scores");
    },
  );

  it.concurrent(
    "should use custom interrupt_on config for subagents",
    { timeout: 120000 },
    async () => {
      const checkpointer = new MemorySaver();
      const agent = createDeepAgent({
        tools: [sampleTool, getWeather, getSoccerScores],
        interruptOn: SAMPLE_TOOL_CONFIG,
        checkpointer,
        subagents: [
          {
            name: "custom_weather_agent",
            description: "Agent that gets weather with custom interrupt config",
            systemPrompt: "Use get_weather tool to get weather information",
            tools: [getWeather],
            // Different config for subagent
            interruptOn: { get_weather: true },
          },
        ],
      });

      const config = { configurable: { thread_id: uuidv4() } };
      const result = await agent.invoke(
        {
          messages: [
            new HumanMessage(
              "Use the custom_weather_agent subagent to get weather in Tokyo",
            ),
          ],
        },
        config,
      );

      // Check that task tool was called
      expect(
        result.messages
          .filter((msg: any) => AIMessage.isInstance(msg))
          .flatMap((msg: any) => msg.tool_calls || []),
      ).toMatchObject([
        { name: "task", args: { subagent_type: "custom_weather_agent" } },
      ]);

      // Subagent should have different interrupt config
      // The get_weather tool should now trigger an interrupt in the subagent
      expect(result.__interrupt__).toBeDefined();

      await agent.invoke(
        new Command({
          resume: {
            decisions: [{ type: "approve" }],
          },
        }),
        config,
      );
      expect(result.messages.length).toBeGreaterThan(0);
    },
  );
});</doc><doc title="Middleware.Test" desc="docs page.">import { describe, it, expect } from "vitest";
import { createAgent } from "langchain";
import {
  createFilesystemMiddleware,
  createSubAgentMiddleware,
  createPatchToolCallsMiddleware,
} from "../../src/index.js";
import {
  SystemMessage,
  HumanMessage,
  AIMessage,
  ToolMessage,
} from "@langchain/core/messages";
import { messagesStateReducer as addMessages } from "@langchain/langgraph";

import { SAMPLE_MODEL } from "../utils.js";

describe("Middleware Integration", () => {
  it("should add filesystem middleware to agent", () => {
    const middleware = [createFilesystemMiddleware()];
    const agent = createAgent({
      model: SAMPLE_MODEL,
      middleware,
      tools: [],
    });
    const channels = Object.keys((agent as any).graph?.channels || {});
    expect(channels).toContain("files");
    const tools = (agent as any).graph?.nodes?.tools?.bound?.tools || [];
    const toolNames = tools.map((t: any) => t.name);
    expect(toolNames).toContain("ls");
    expect(toolNames).toContain("read_file");
    expect(toolNames).toContain("write_file");
    expect(toolNames).toContain("edit_file");
  });

  it("should add subagent middleware to agent", () => {
    const middleware = [
      createSubAgentMiddleware({
        defaultModel: SAMPLE_MODEL,
        defaultTools: [],
        subagents: [],
      }),
    ];
    const agent = createAgent({
      model: SAMPLE_MODEL,
      middleware,
      tools: [],
    });

    const tools = (agent as any).graph?.nodes?.tools?.bound?.tools || [];
    const toolNames = tools.map((t: any) => t.name);
    expect(toolNames).toContain("task");
  });

  it("should add multiple middleware to agent", () => {
    const middleware = [
      createFilesystemMiddleware(),
      createSubAgentMiddleware({
        defaultModel: SAMPLE_MODEL,
        defaultTools: [],
        subagents: [],
      }),
    ];
    const agent = createAgent({
      model: SAMPLE_MODEL,
      middleware,
      tools: [],
    });
    const channels = Object.keys((agent as any).graph?.channels || {});
    expect(channels).toContain("files");
    const tools = (agent as any).graph?.nodes?.tools?.bound?.tools || [];
    const toolNames = tools.map((t: any) => t.name);
    expect(toolNames).toContain("ls");
    expect(toolNames).toContain("read_file");
    expect(toolNames).toContain("write_file");
    expect(toolNames).toContain("edit_file");
    expect(toolNames).toContain("task");
  });
});

describe("FilesystemMiddleware", () => {
  it("should initialize with default backend (StateBackend)", () => {
    const middleware = createFilesystemMiddleware();
    expect(middleware).toBeDefined();
    expect(middleware.name).toBe("FilesystemMiddleware");
    const tools = middleware.tools || [];
    expect(tools.length).toBeGreaterThanOrEqual(6); // ls, read, write, edit, glob, grep
    expect(tools.map((t) => t.name)).toContain("ls");
    expect(tools.map((t) => t.name)).toContain("read_file");
    expect(tools.map((t) => t.name)).toContain("write_file");
    expect(tools.map((t) => t.name)).toContain("edit_file");
    expect(tools.map((t) => t.name)).toContain("glob");
    expect(tools.map((t) => t.name)).toContain("grep");
  });

  it("should initialize with custom backend", () => {
    const middleware = createFilesystemMiddleware({
      backend: undefined, // Will use default StateBackend
    });
    expect(middleware).toBeDefined();
    expect(middleware.name).toBe("FilesystemMiddleware");
    const tools = middleware.tools || [];
    expect(tools.length).toBeGreaterThanOrEqual(6);
  });

  it("should use custom tool descriptions", () => {
    const customDesc = "Custom ls tool description";
    const middleware = createFilesystemMiddleware({
      customToolDescriptions: {
        ls: customDesc,
      },
    });
    expect(middleware).toBeDefined();
    const tools = middleware.tools || [];
    const lsTool = tools.find((t) => t.name === "ls");
    expect(lsTool).toBeDefined();
    expect(lsTool?.description).toBe(customDesc);
  });

  it("should use custom tool descriptions with backend factory", () => {
    const customDesc = "Custom ls tool description";
    const middleware = createFilesystemMiddleware({
      backend: undefined, // Will use default
      customToolDescriptions: {
        ls: customDesc,
      },
    });
    expect(middleware).toBeDefined();
    const tools = middleware.tools || [];
    const lsTool = tools.find((t) => t.name === "ls");
    expect(lsTool).toBeDefined();
    expect(lsTool?.description).toBe(customDesc);
  });
});

describe("SubAgentMiddleware", () => {
  it("should initialize with default settings", () => {
    const middleware = createSubAgentMiddleware({
      defaultModel: SAMPLE_MODEL,
    });
    expect(middleware).toBeDefined();
    expect(middleware.name).toBe("subAgentMiddleware");
    const tools = middleware.tools || [];
    expect(tools).toHaveLength(1);
    expect(tools[0].name).toBe("task");
    expect(tools[0].description).toContain("general-purpose");
  });

  it("should initialize with default tools", () => {
    const middleware = createSubAgentMiddleware({
      defaultModel: SAMPLE_MODEL,
      defaultTools: [],
    });
    expect(middleware).toBeDefined();
    const tools = middleware.tools || [];
    expect(tools).toHaveLength(1);
    expect(tools[0].name).toBe("task");
  });
});

describe("PatchToolCallsMiddleware", () => {
  it("should pass through messages without tool calls", async () => {
    const inputMessages = [
      new SystemMessage({ content: "You are a helpful assistant.", id: "1" }),
      new HumanMessage({ content: "Hello, how are you?", id: "2" }),
    ];
    const middleware = createPatchToolCallsMiddleware();
    const beforeAgentHook = (middleware as any).beforeAgent;
    const stateUpdate = await beforeAgentHook({
      messages: inputMessages,
    });
    expect(stateUpdate).toBeDefined();
    expect(stateUpdate.messages).toHaveLength(3);
    expect(stateUpdate.messages[0]._getType()).toBe("remove");
    expect(stateUpdate.messages[1].content).toBe(
      "You are a helpful assistant."
    );
    expect(stateUpdate.messages[2].content).toBe("Hello, how are you?");
  });

  it("should patch a single missing tool call", async () => {
    const inputMessages = [
      new SystemMessage({ content: "You are a helpful assistant.", id: "1" }),
      new HumanMessage({ content: "Hello, how are you?", id: "2" }),
      new AIMessage({
        content: "I'm doing well, thank you!",
        tool_calls: [
          {
            id: "123",
            name: "get_events_for_days",
            args: { date_str: "2025-01-01" },
          },
        ],
        id: "3",
      }),
      new HumanMessage({ content: "What is the weather in Tokyo?", id: "4" }),
    ];

    const middleware = createPatchToolCallsMiddleware();
    const beforeAgentHook = (middleware as any).beforeAgent;
    const stateUpdate = await beforeAgentHook({
      messages: inputMessages,
    });
    expect(stateUpdate).toBeDefined();
    expect(stateUpdate.messages).toHaveLength(6);
    expect(stateUpdate.messages[0]._getType()).toBe("remove");
    expect(stateUpdate.messages[1]).toBe(inputMessages[0]);
    expect(stateUpdate.messages[2]).toBe(inputMessages[1]);
    expect(stateUpdate.messages[3]).toBe(inputMessages[2]);
    expect(stateUpdate.messages[4]._getType()).toBe("tool");
    expect((stateUpdate.messages[4] as any).tool_call_id).toBe("123");
    expect((stateUpdate.messages[4] as any).name).toBe("get_events_for_days");
    expect((stateUpdate.messages[4] as any).content).toContain("cancelled");
    expect(stateUpdate.messages[5]).toBe(inputMessages[3]);

    const updatedMessages = addMessages(inputMessages, stateUpdate.messages);
    expect(updatedMessages).toHaveLength(5);
    expect(updatedMessages[0]).toBe(inputMessages[0]);
    expect(updatedMessages[1]).toBe(inputMessages[1]);
    expect(updatedMessages[2]).toBe(inputMessages[2]);
    expect(updatedMessages[3]._getType()).toBe("tool");
    expect((updatedMessages[3] as any).tool_call_id).toBe("123");
    expect(updatedMessages[4]).toBe(inputMessages[3]);
  });

  it("should not patch when tool message exists", async () => {
    const inputMessages = [
      new SystemMessage({ content: "You are a helpful assistant.", id: "1" }),
      new HumanMessage({ content: "Hello, how are you?", id: "2" }),
      new AIMessage({
        content: "I'm doing well, thank you!",
        tool_calls: [
          {
            id: "123",
            name: "get_events_for_days",
            args: { date_str: "2025-01-01" },
          },
        ],
        id: "3",
      }),
      new ToolMessage({
        content: "I have no events for that date.",
        tool_call_id: "123",
        id: "4",
      }),
      new HumanMessage({ content: "What is the weather in Tokyo?", id: "5" }),
    ];

    const middleware = createPatchToolCallsMiddleware();
    const beforeAgentHook = (middleware as any).beforeAgent;
    const stateUpdate = await beforeAgentHook({
      messages: inputMessages,
    });

    expect(stateUpdate).toBeDefined();
    expect(stateUpdate.messages).toHaveLength(6);
    expect(stateUpdate.messages[0]._getType()).toBe("remove");
    expect(stateUpdate.messages.slice(1)).toEqual(inputMessages);

    const updatedMessages = addMessages(inputMessages, stateUpdate.messages);
    expect(updatedMessages).toHaveLength(5);
    expect(updatedMessages).toEqual(inputMessages);
  });

  it("should patch multiple missing tool calls", async () => {
    const inputMessages = [
      new SystemMessage({ content: "You are a helpful assistant.", id: "1" }),
      new HumanMessage({ content: "Hello, how are you?", id: "2" }),
      new AIMessage({
        content: "I'm doing well, thank you!",
        tool_calls: [
          {
            id: "123",
            name: "get_events_for_days",
            args: { date_str: "2025-01-01" },
          },
        ],
        id: "3",
      }),
      new HumanMessage({ content: "What is the weather in Tokyo?", id: "4" }),
      new AIMessage({
        content: "I'm doing well, thank you!",
        tool_calls: [
          {
            id: "456",
            name: "get_events_for_days",
            args: { date_str: "2025-01-01" },
          },
        ],
        id: "5",
      }),
      new HumanMessage({ content: "What is the weather in Tokyo?", id: "6" }),
    ];
    const middleware = createPatchToolCallsMiddleware();
    const beforeAgentHook = (middleware as any).beforeAgent;
    const stateUpdate = await beforeAgentHook({
      messages: inputMessages,
    });

    expect(stateUpdate).toBeDefined();
    expect(stateUpdate.messages).toHaveLength(9);
    expect(stateUpdate.messages[0]._getType()).toBe("remove");
    expect(stateUpdate.messages[1]).toBe(inputMessages[0]);
    expect(stateUpdate.messages[2]).toBe(inputMessages[1]);
    expect(stateUpdate.messages[3]).toBe(inputMessages[2]);
    expect(stateUpdate.messages[4]._getType()).toBe("tool");
    expect((stateUpdate.messages[4] as any).tool_call_id).toBe("123");
    expect(stateUpdate.messages[5]).toBe(inputMessages[3]);
    expect(stateUpdate.messages[6]).toBe(inputMessages[4]);
    expect(stateUpdate.messages[7]._getType()).toBe("tool");
    expect((stateUpdate.messages[7] as any).tool_call_id).toBe("456");
    expect(stateUpdate.messages[8]).toBe(inputMessages[5]);

    const updatedMessages = addMessages(inputMessages, stateUpdate.messages);
    expect(updatedMessages).toHaveLength(8);
    expect(updatedMessages[0]).toBe(inputMessages[0]);
    expect(updatedMessages[1]).toBe(inputMessages[1]);
    expect(updatedMessages[2]).toBe(inputMessages[2]);
    expect(updatedMessages[3].type).toBe("tool");
    expect((updatedMessages[3] as any).tool_call_id).toBe("123");
    expect(updatedMessages[4]).toBe(inputMessages[3]);
    expect(updatedMessages[5]).toBe(inputMessages[4]);
    expect(updatedMessages[6].type).toBe("tool");
    expect((updatedMessages[6] as any).tool_call_id).toBe("456");
    expect(updatedMessages[7]).toBe(inputMessages[5]);
  });
});</doc><doc title="Subagents.Test" desc="docs page.">import { describe, it, expect } from "vitest";
import { createAgent, createMiddleware, ReactAgent } from "langchain";
import { AIMessage, BaseMessage, HumanMessage } from "@langchain/core/messages";
import { createSubAgentMiddleware } from "../../src/index.js";
import {
  SAMPLE_MODEL,
  getWeather,
  getSoccerScores,
  extractToolsFromAgent,
} from "../utils.js";

const WeatherToolMiddleware = createMiddleware({
  name: "weatherToolMiddleware",
  tools: [getWeather],
});

/**
 * Helper to extract all tool calls from agent response
 */
function extractAllToolCalls(
  response: any,
): Array<{ name: string; args: Record<string, any>; model?: string }> {
  const messages = response.messages || [];
  const aiMessages = messages.filter((msg: any) => AIMessage.isInstance(msg));
  return aiMessages.flatMap((msg: any) =>
    (msg.tool_calls || []).map((toolCall: any) => ({
      name: toolCall.name,
      args: toolCall.args,
      model: msg.response_metadata?.model_name || undefined,
    })),
  );
}

/**
 * Helper to assert expected actions in subgraph
 * This collects all tool calls from the agent execution
 */
async function assertExpectedSubgraphActions(
  expectedToolCalls: Array<{
    name: string;
    args?: Record<string, any>;
    model?: string;
  }>,
  agent: ReactAgent,
  input: any,
) {
  const actualToolCalls: Array<{
    name: string;
    args: Record<string, any>;
    model?: string;
  }> = [];

  for await (const chunk of await agent.graph.stream(input, {
    streamMode: ["updates"],
    subgraphs: true,
  })) {
    const update = chunk[2] ?? {};

    if (!("model_request" in update)) continue;
    const messages = update.model_request.messages as BaseMessage[];

    const lastAiMessage = messages
      .filter((msg) => AIMessage.isInstance(msg))
      .at(-1);

    if (!lastAiMessage) continue;

    actualToolCalls.push(
      ...(lastAiMessage.tool_calls ?? []).map((toolCall) => ({
        name: toolCall.name,
        args: toolCall.args,
        model: lastAiMessage.response_metadata?.model_name || undefined,
      })),
    );
  }

  expect(actualToolCalls).toMatchObject(expectedToolCalls);
}

describe("Subagent Middleware Integration Tests", () => {
  it.concurrent(
    "should invoke general-purpose subagent",
    { timeout: 60000 },
    async () => {
      const agent = createAgent({
        model: SAMPLE_MODEL,
        systemPrompt:
          "Use the general-purpose subagent to get the weather in a city.",
        middleware: [
          createSubAgentMiddleware({
            defaultModel: SAMPLE_MODEL,
            defaultTools: [getWeather] as any,
          }),
        ],
      });

      // Check that task tool is available
      const tools = extractToolsFromAgent(agent);
      expect(tools.task).toBeDefined();

      const response = await agent.invoke({
        messages: [new HumanMessage("What is the weather in Tokyo?")],
      });

      const toolCalls = extractAllToolCalls(response);
      const taskCall = toolCalls.find((tc) => tc.name === "task");

      expect(taskCall).toBeDefined();
      expect(taskCall!.args.subagent_type).toBe("general-purpose");
    },
  );

  it.concurrent(
    "should invoke defined subagent",
    { timeout: 60000 },
    async () => {
      const agent = createAgent({
        model: SAMPLE_MODEL,
        systemPrompt: "Use the task tool to call a subagent.",
        middleware: [
          createSubAgentMiddleware({
            defaultModel: SAMPLE_MODEL,
            defaultTools: [],
            subagents: [
              {
                name: "weather",
                description: "This subagent can get weather in cities.",
                systemPrompt:
                  "Use the get_weather tool to get the weather in a city.",
                tools: [getWeather],
              },
            ],
          }),
        ],
      });

      // Check that task tool is available
      const tools = extractToolsFromAgent(agent);
      expect(tools.task).toBeDefined();

      const response = await agent.invoke({
        messages: [new HumanMessage("What is the weather in Tokyo?")],
      });

      const toolCalls = extractAllToolCalls(response);
      const taskCall = toolCalls.find((tc) => tc.name === "task");

      expect(taskCall).toBeDefined();
      expect(taskCall!.args.subagent_type).toBe("weather");
    },
  );

  it.concurrent(
    "should make tool calls within subagent",
    { timeout: 60000 },
    async () => {
      const agent = createAgent({
        model: SAMPLE_MODEL,
        systemPrompt: "Use the task tool to call a subagent.",
        middleware: [
          createSubAgentMiddleware({
            defaultModel: SAMPLE_MODEL,
            defaultTools: [],
            subagents: [
              {
                name: "weather",
                description: "This subagent can get weather in cities.",
                systemPrompt:
                  "Use the get_weather tool to get the weather in a city.",
                tools: [getWeather],
              },
            ],
          }),
        ],
      });

      const expectedToolCalls = [
        { name: "task", args: { subagent_type: "weather" } },
        { name: "get_weather" },
      ];

      await assertExpectedSubgraphActions(expectedToolCalls, agent, {
        messages: [new HumanMessage("What is the weather in Tokyo?")],
      });
    },
  );

  it.concurrent(
    "should use custom model in subagent",
    { timeout: 60000 },
    async () => {
      const agent = createAgent({
        model: SAMPLE_MODEL,
        systemPrompt: "Use the task tool to call a subagent.",
        middleware: [
          createSubAgentMiddleware({
            defaultModel: SAMPLE_MODEL,
            defaultTools: [],
            subagents: [
              {
                name: "weather",
                description: "This subagent can get weather in cities.",
                systemPrompt:
                  "Use the get_weather tool to get the weather in a city.",
                tools: [getWeather],
                model: "gpt-4.1", // Custom model for subagent
              },
            ],
          }),
        ],
      });

      const expectedToolCalls = [
        { name: "task", args: { subagent_type: "weather" } },
        { name: "get_weather" },
      ];

      await assertExpectedSubgraphActions(expectedToolCalls, agent, {
        messages: [new HumanMessage("What is the weather in Tokyo?")],
      });
    },
  );

  it.concurrent(
    "should use custom middleware in subagent",
    { timeout: 60000 },
    async () => {
      const agent = createAgent({
        model: SAMPLE_MODEL,
        systemPrompt: "Use the task tool to call a subagent.",
        middleware: [
          createSubAgentMiddleware({
            defaultModel: SAMPLE_MODEL,
            defaultTools: [],
            subagents: [
              {
                name: "weather",
                description: "This subagent can get weather in cities.",
                systemPrompt:
                  "Use the get_weather tool to get the weather in a city.",
                tools: [], // No tools directly, only via middleware
                model: "gpt-4.1",
                middleware: [WeatherToolMiddleware],
              },
            ],
          }),
        ],
      });

      const expectedToolCalls = [
        { name: "task", args: { subagent_type: "weather" } },
        { name: "get_weather" },
      ];

      await assertExpectedSubgraphActions(expectedToolCalls, agent, {
        messages: [new HumanMessage("What is the weather in Tokyo?")],
      });
    },
  );

  it.concurrent(
    "should handle multiple subagents without middleware accumulation",
    { timeout: 120000 },
    async () => {
      const agent = createAgent({
        model: SAMPLE_MODEL,
        systemPrompt: "Use the task tool to call subagents.",
        middleware: [
          createSubAgentMiddleware({
            defaultModel: SAMPLE_MODEL,
            defaultTools: [],
            subagents: [
              {
                name: "weather",
                description: "Get weather information",
                systemPrompt: "Use get_weather tool",
                tools: [getWeather],
              },
              {
                name: "soccer",
                description: "Get soccer scores",
                systemPrompt: "Use get_soccer_scores tool",
                tools: [getSoccerScores],
              },
            ],
          }),
        ],
      });

      // Verify both subagents work independently
      const response1 = await agent.invoke({
        messages: [new HumanMessage("What is the weather in Tokyo?")],
      });

      const toolCalls1 = extractAllToolCalls(response1);
      const taskCall1 = toolCalls1.find((tc) => tc.name === "task");
      expect(taskCall1?.args.subagent_type).toBe("weather");

      const response2 = await agent.invoke({
        messages: [
          new HumanMessage("What are the latest scores for Manchester United?"),
        ],
      });

      const toolCalls2 = extractAllToolCalls(response2);
      const taskCall2 = toolCalls2.find((tc) => tc.name === "task");
      expect(taskCall2?.args.subagent_type).toBe("soccer");
    },
  );

  it.concurrent(
    "should initialize subagent middleware with default settings",
    { timeout: 60000 },
    async () => {
      const middleware = createSubAgentMiddleware({
        defaultModel: SAMPLE_MODEL,
        defaultTools: [],
        subagents: [],
      });

      expect(middleware).toBeDefined();
      expect(middleware.name).toBe("subAgentMiddleware");
      expect(middleware.tools).toBeDefined();
      expect(middleware.tools).toHaveLength(1);
      expect(middleware.tools![0].name).toBe("task");

      const agent = createAgent({
        model: SAMPLE_MODEL,
        middleware: [middleware],
      });

      const tools = extractToolsFromAgent(agent);
      expect(tools.task).toBeDefined();
      expect(tools.task.description).toContain("general-purpose");
    },
  );

  it.concurrent(
    "should initialize general-purpose subagent with default tools",
    { timeout: 60000 },
    async () => {
      const agent = createAgent({
        model: SAMPLE_MODEL,
        systemPrompt: "Use the general-purpose subagent to call tools.",
        middleware: [
          createSubAgentMiddleware({
            defaultModel: SAMPLE_MODEL,
            defaultTools: [getWeather, getSoccerScores],
          }),
        ],
      });

      const response = await agent.invoke({
        messages: [
          new HumanMessage(
            "Use the general-purpose subagent to get the weather in Tokyo",
          ),
        ],
      });

      const toolCalls = extractAllToolCalls(response);
      const taskCall = toolCalls.find((tc) => tc.name === "task");

      expect(taskCall).toBeDefined();
      expect(taskCall!.args.subagent_type).toBe("general-purpose");
    },
  );

  it.concurrent(
    "should use custom system prompt in general-purpose subagent",
    { timeout: 60000 },
    async () => {
      const customPrompt =
        "You are a specialized assistant. In every response, you must include the word 'specialized'.";

      const agent = createAgent({
        model: SAMPLE_MODEL,
        systemPrompt:
          "Use the general-purpose subagent to answer the user's question.",
        middleware: [
          createSubAgentMiddleware({
            defaultModel: SAMPLE_MODEL,
            defaultTools: [],
            systemPrompt: customPrompt,
          }),
        ],
      });

      const response = await agent.invoke({
        messages: [
          new HumanMessage(
            "Use the general-purpose subagent to tell me about your capabilities",
          ),
        ],
      });

      const toolCalls = extractAllToolCalls(response);
      const taskCall = toolCalls.find((tc) => tc.name === "task");
      expect(taskCall).toBeDefined();
      expect(taskCall!.args.subagent_type).toBe("general-purpose");
      expect(response.messages.length).toBeGreaterThan(0);
    },
  );
});</doc><doc title="Composite.Test" desc="docs page.">import { describe, it, expect, beforeEach, vi } from "vitest";
import { CompositeBackend } from "../../../src/backends/composite.js";
import { StateBackend } from "../../../src/backends/state.js";
import { StoreBackend } from "../../../src/backends/store.js";
import { FilesystemBackend } from "../../../src/backends/filesystem.js";
import { InMemoryStore } from "@langchain/langgraph-checkpoint";
import { getCurrentTaskInput } from "@langchain/langgraph";
import * as fs from "fs/promises";
import * as fsSync from "fs";
import * as path from "path";
import * as os from "os";

vi.mock("@langchain/langgraph", async (importOriginal) => {
  const actual = await importOriginal();
  return {
    ...(actual as any),
    getCurrentTaskInput: vi.fn(),
  };
});

/**
 * Helper to create a unique temporary directory for each test
 */
function createTempDir(): string {
  return fsSync.mkdtempSync(path.join(os.tmpdir(), "deepagents-composite-"));
}

/**
 * Helper to recursively remove a directory
 */
async function removeDir(dirPath: string) {
  try {
    await fs.rm(dirPath, { recursive: true, force: true });
  } catch (err) {
    // Ignore errors during cleanup
  }
}

/**
 * Helper to write a file with automatic parent directory creation
 */
async function writeFile(filePath: string, content: string) {
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, content, "utf-8");
}

/**
 * Helper to create a mock config with state and store
 */
function makeConfig() {
  const state = {
    messages: [],
    files: {},
  };
  const store = new InMemoryStore();

  vi.mocked(getCurrentTaskInput).mockReturnValue(state);

  const stateAndStore = {
    state,
    store,
  };

  const config = {
    store,
    configurable: {},
  };

  return { state, store, stateAndStore, config };
}

describe("CompositeBackend", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("should route operations between StateBackend and StoreBackend", async () => {
    const { state, stateAndStore } = makeConfig();

    const composite = new CompositeBackend(new StateBackend(stateAndStore), {
      "/memories/": new StoreBackend(stateAndStore),
    });

    const stateRes = await composite.write("/file.txt", "alpha");
    expect(stateRes.filesUpdate).toBeDefined();
    expect(stateRes.path).toBe("/file.txt");
    Object.assign(state.files, stateRes.filesUpdate!);

    const storeRes = await composite.write("/memories/readme.md", "beta");
    expect(storeRes.error).toBeUndefined();
    expect(storeRes.filesUpdate).toBeNull();

    const infos = await composite.lsInfo("/");
    const paths = infos.map((i) => i.path);
    expect(paths).toContain("/file.txt");
    expect(paths).toContain("/memories/");

    const matches1 = await composite.grepRaw("alpha", "/");
    expect(Array.isArray(matches1)).toBe(true);
    if (Array.isArray(matches1)) {
      expect(matches1.some((m) => m.path === "/file.txt")).toBe(true);
    }

    const matches2 = await composite.grepRaw("beta", "/");
    expect(Array.isArray(matches2)).toBe(true);
    if (Array.isArray(matches2)) {
      expect(matches2.some((m) => m.path === "/memories/readme.md")).toBe(true);
    }

    const glob = await composite.globInfo("**/*.md", "/");
    expect(glob.some((i) => i.path === "/memories/readme.md")).toBe(true);
  });

  it("should handle multiple routes", async () => {
    const { state, stateAndStore } = makeConfig();

    const composite = new CompositeBackend(new StateBackend(stateAndStore), {
      "/memories/": new StoreBackend(stateAndStore),
      "/archive/": new StoreBackend(stateAndStore),
      "/cache/": new StoreBackend(stateAndStore),
    });

    const resState = await composite.write("/temp.txt", "ephemeral data");
    expect(resState.filesUpdate).toBeDefined();
    expect(resState.path).toBe("/temp.txt");
    Object.assign(state.files, resState.filesUpdate!);

    const resMem = await composite.write(
      "/memories/important.md",
      "long-term memory"
    );
    expect(resMem.filesUpdate).toBeNull();
    expect(resMem.path).toBe("/important.md");

    const resArch = await composite.write("/archive/old.log", "archived log");
    expect(resArch.filesUpdate).toBeNull();
    expect(resArch.path).toBe("/old.log");

    const resCache = await composite.write(
      "/cache/session.json",
      "cached session"
    );
    expect(resCache.filesUpdate).toBeNull();
    expect(resCache.path).toBe("/session.json");

    const infos = await composite.lsInfo("/");
    const paths = infos.map((i) => i.path);
    expect(paths).toContain("/temp.txt");
    expect(paths).toContain("/memories/");
    expect(paths).toContain("/archive/");
    expect(paths).toContain("/cache/");

    const memInfos = await composite.lsInfo("/memories/");
    const memPaths = memInfos.map((i) => i.path);
    expect(memPaths).toContain("/memories/important.md");
    expect(memPaths).not.toContain("/temp.txt");
    expect(memPaths).not.toContain("/archive/old.log");

    const allMatches = await composite.grepRaw(".", "/");
    expect(Array.isArray(allMatches)).toBe(true);
    if (Array.isArray(allMatches)) {
      const pathsWithContent = allMatches.map((m) => m.path);
      expect(pathsWithContent).toContain("/temp.txt");
      expect(pathsWithContent).toContain("/memories/important.md");
      expect(pathsWithContent).toContain("/archive/old.log");
      expect(pathsWithContent).toContain("/cache/session.json");
    }

    const globResults = await composite.globInfo("**/*.md", "/");
    expect(globResults.some((i) => i.path === "/memories/important.md")).toBe(
      true
    );

    const editRes = await composite.edit(
      "/memories/important.md",
      "long-term",
      "persistent",
      false
    );
    expect(editRes.error).toBeUndefined();
    expect(editRes.occurrences).toBe(1);

    const updatedContent = await composite.read("/memories/important.md");
    expect(updatedContent).toContain("persistent memory");
  });

  it("should handle nested directories correctly", async () => {
    const { state, stateAndStore } = makeConfig();

    const composite = new CompositeBackend(new StateBackend(stateAndStore), {
      "/memories/": new StoreBackend(stateAndStore),
      "/archive/": new StoreBackend(stateAndStore),
    });

    const stateFiles: Record<string, string> = {
      "/temp.txt": "temp",
      "/work/file1.txt": "work file 1",
      "/work/projects/proj1.txt": "project 1",
    };

    for (const [path, content] of Object.entries(stateFiles)) {
      const res = await composite.write(path, content);
      if (res.filesUpdate) {
        Object.assign(state.files, res.filesUpdate);
      }
    }

    const memoryFiles: Record<string, string> = {
      "/memories/important.txt": "important",
      "/memories/diary/entry1.txt": "diary entry",
    };

    for (const [path, content] of Object.entries(memoryFiles)) {
      await composite.write(path, content);
    }

    const archiveFiles: Record<string, string> = {
      "/archive/old.txt": "old",
      "/archive/2023/log.txt": "2023 log",
    };

    for (const [path, content] of Object.entries(archiveFiles)) {
      await composite.write(path, content);
    }

    const rootListing = await composite.lsInfo("/");
    const rootPaths = rootListing.map((fi) => fi.path);
    expect(rootPaths).toContain("/temp.txt");
    expect(rootPaths).toContain("/work/");
    expect(rootPaths).toContain("/memories/");
    expect(rootPaths).toContain("/archive/");
    expect(rootPaths).not.toContain("/work/file1.txt");
    expect(rootPaths).not.toContain("/memories/important.txt");

    const workListing = await composite.lsInfo("/work/");
    const workPaths = workListing.map((fi) => fi.path);
    expect(workPaths).toContain("/work/file1.txt");
    expect(workPaths).toContain("/work/projects/");
    expect(workPaths).not.toContain("/work/projects/proj1.txt");

    const memListing = await composite.lsInfo("/memories/");
    const memPaths = memListing.map((fi) => fi.path);
    expect(memPaths).toContain("/memories/important.txt");
    expect(memPaths).toContain("/memories/diary/");
    expect(memPaths).not.toContain("/memories/diary/entry1.txt");

    const archListing = await composite.lsInfo("/archive/");
    const archPaths = archListing.map((fi) => fi.path);
    expect(archPaths).toContain("/archive/old.txt");
    expect(archPaths).toContain("/archive/2023/");
    expect(archPaths).not.toContain("/archive/2023/log.txt");
  });

  it("should handle trailing slashes in ls", async () => {
    const { state, stateAndStore } = makeConfig();

    const composite = new CompositeBackend(new StateBackend(stateAndStore), {
      "/store/": new StoreBackend(stateAndStore),
    });

    const res = await composite.write("/file.txt", "content");
    Object.assign(state.files, res.filesUpdate!);

    await composite.write("/store/item.txt", "store content");

    const listing = await composite.lsInfo("/");
    const paths = listing.map((fi) => fi.path);
    expect(paths).toEqual(paths.slice().sort());

    const emptyListing1 = await composite.lsInfo("/store/nonexistent/");
    expect(emptyListing1).toEqual([]);

    const emptyListing2 = await composite.lsInfo("/nonexistent/");
    expect(emptyListing2).toEqual([]);

    const listing1 = await composite.lsInfo("/store/");
    const listing2 = await composite.lsInfo("/store");
    expect(listing1.map((fi) => fi.path)).toEqual(
      listing2.map((fi) => fi.path)
    );
  });

  it("should handle large tool result interception with default route", async () => {
    const { stateAndStore, config } = makeConfig();
    const { createFilesystemMiddleware } = await import(
      "../../../src/middleware/fs.js"
    );
    const { ToolMessage } = await import("@langchain/core/messages");
    const { Command } = await import("@langchain/langgraph");

    const middleware = createFilesystemMiddleware({
      backend: (stateAndStore) =>
        new CompositeBackend(new StateBackend(stateAndStore), {
          "/memories/": new StoreBackend(stateAndStore),
        }),
      toolTokenLimitBeforeEvict: 1000,
    });

    const largeContent = "z".repeat(5000);
    const toolMessage = new ToolMessage({
      content: largeContent,
      tool_call_id: "test_789",
      name: "test_tool",
    });

    const mockToolFn = async () => toolMessage;
    const mockToolCall = { name: "test_tool", args: {}, id: "test_789" };

    const result = await (middleware as any).wrapToolCall(
      {
        toolCall: mockToolCall,
        config: config,
        state: { files: {}, messages: [] },
        runtime: {},
      },
      mockToolFn
    );

    expect(result).toBeInstanceOf(Command);
    expect(result.update.files).toBeDefined();
    expect(result.update.files["/large_tool_results/test_789"]).toBeDefined();
    expect(result.update.files["/large_tool_results/test_789"].content).toEqual(
      [largeContent]
    );

    expect(result.update.messages).toHaveLength(1);
    expect(result.update.messages[0].content).toContain(
      "Tool result too large"
    );
  });

  it("should handle large tool result interception routed to store", async () => {
    const { stateAndStore, config, store } = makeConfig();
    const { createFilesystemMiddleware } = await import(
      "../../../src/middleware/fs.js"
    );
    const { ToolMessage } = await import("@langchain/core/messages");

    const middleware = createFilesystemMiddleware({
      backend: (stateAndStore) =>
        new CompositeBackend(new StateBackend(stateAndStore), {
          "/large_tool_results/": new StoreBackend(stateAndStore),
        }),
      toolTokenLimitBeforeEvict: 1000,
    });

    const largeContent = "w".repeat(5000);
    const toolMessage = new ToolMessage({
      content: largeContent,
      tool_call_id: "test_routed_123",
      name: "test_tool",
    });

    const mockToolFn = async () => toolMessage;
    const mockToolCall = { name: "test_tool", args: {}, id: "test_routed_123" };

    const result = await (middleware as any).wrapToolCall(
      {
        toolCall: mockToolCall,
        config: config,
        state: { files: {}, messages: [] },
        runtime: {},
      },
      mockToolFn
    );

    expect(result).toBeInstanceOf(ToolMessage);
    expect(result.content).toContain("Tool result too large");
    expect(result.content).toContain("/large_tool_results/test_routed_123");

    const storedContent = await config.store.get(
      ["filesystem"],
      "/test_routed_123"
    );
    expect(storedContent).toBeDefined();
    expect((storedContent!.value as any).content).toEqual([largeContent]);
  });

  it("should work with FilesystemBackend as default and StoreBackend route", async () => {
    const tmpDir = createTempDir();
    try {
      const { stateAndStore } = makeConfig();

      const fsBackend = new FilesystemBackend({
        rootDir: tmpDir,
        virtualMode: true,
      });
      const storeBackend = new StoreBackend(stateAndStore);
      const composite = new CompositeBackend(fsBackend, {
        "/memories/": storeBackend,
      });

      const r1 = await composite.write("/hello.txt", "hello");
      expect(r1.error).toBeUndefined();
      expect(r1.filesUpdate).toBeNull();

      const r2 = await composite.write("/memories/notes.md", "note");
      expect(r2.error).toBeUndefined();
      expect(r2.filesUpdate).toBeNull(); // Store also returns null

      const infosRoot = await composite.lsInfo("/");
      expect(infosRoot.some((i) => i.path === "/hello.txt")).toBe(true);
      expect(infosRoot.some((i) => i.path === "/memories/")).toBe(true);

      const infosMem = await composite.lsInfo("/memories/");
      expect(infosMem.some((i) => i.path === "/memories/notes.md")).toBe(true);

      const gm1 = await composite.grepRaw("hello", "/");
      expect(Array.isArray(gm1)).toBe(true);
      if (Array.isArray(gm1)) {
        expect(gm1.some((m) => m.path === "/hello.txt")).toBe(true);
      }

      const gm2 = await composite.grepRaw("note", "/");
      expect(Array.isArray(gm2)).toBe(true);
      if (Array.isArray(gm2)) {
        expect(gm2.some((m) => m.path === "/memories/notes.md")).toBe(true);
      }

      const gl = await composite.globInfo("*.md", "/");
      expect(gl.some((i) => i.path === "/memories/notes.md")).toBe(true);
    } finally {
      await removeDir(tmpDir);
    }
  });

  it("should work with StoreBackend as default and another StoreBackend route", async () => {
    const { stateAndStore } = makeConfig();

    const defaultStore = new StoreBackend(stateAndStore);
    const memoriesStore = new StoreBackend(stateAndStore);

    const composite = new CompositeBackend(defaultStore, {
      "/memories/": memoriesStore,
    });

    const res1 = await composite.write("/notes.txt", "default store content");
    expect(res1.error).toBeUndefined();
    expect(res1.path).toBe("/notes.txt");

    const res2 = await composite.write(
      "/memories/important.txt",
      "routed store content"
    );
    expect(res2.error).toBeUndefined();
    expect(res2.path).toBe("/important.txt");

    const content1 = await composite.read("/notes.txt");
    expect(content1).toContain("default store content");

    const content2 = await composite.read("/memories/important.txt");
    expect(content2).toContain("routed store content");

    const infos = await composite.lsInfo("/");
    const paths = infos.map((i) => i.path);
    expect(paths).toContain("/notes.txt");
    expect(paths).toContain("/memories/");

    const matches1 = await composite.grepRaw("default", "/");
    expect(Array.isArray(matches1)).toBe(true);
    if (Array.isArray(matches1)) {
      expect(matches1.some((m) => m.path === "/notes.txt")).toBe(true);
    }

    const matches2 = await composite.grepRaw("routed", "/");
    expect(Array.isArray(matches2)).toBe(true);
    if (Array.isArray(matches2)) {
      expect(matches2.some((m) => m.path === "/memories/important.txt")).toBe(
        true
      );
    }
  });

  it("should handle nested directories with FilesystemBackend and StoreBackend", async () => {
    const tmpDir = createTempDir();
    try {
      const { stateAndStore } = makeConfig();

      const files: Record<string, string> = {
        [path.join(tmpDir, "local.txt")]: "local file",
        [path.join(tmpDir, "src", "main.py")]: "code",
        [path.join(tmpDir, "src", "utils", "helper.py")]: "utils",
      };

      for (const [filePath, content] of Object.entries(files)) {
        await writeFile(filePath, content);
      }

      const fsBackend = new FilesystemBackend({
        rootDir: tmpDir,
        virtualMode: true,
      });
      const storeBackend = new StoreBackend(stateAndStore);
      const composite = new CompositeBackend(fsBackend, {
        "/memories/": storeBackend,
      });

      await composite.write("/memories/note1.txt", "note 1");
      await composite.write("/memories/deep/note2.txt", "note 2");
      await composite.write("/memories/deep/nested/note3.txt", "note 3");

      const rootListing = await composite.lsInfo("/");
      const rootPaths = rootListing.map((fi) => fi.path);
      expect(rootPaths).toContain("/local.txt");
      expect(rootPaths).toContain("/src/");
      expect(rootPaths).toContain("/memories/");
      expect(rootPaths).not.toContain("/src/main.py");
      expect(rootPaths).not.toContain("/memories/note1.txt");

      const srcListing = await composite.lsInfo("/src/");
      const srcPaths = srcListing.map((fi) => fi.path);
      expect(srcPaths).toContain("/src/main.py");
      expect(srcPaths).toContain("/src/utils/");
      expect(srcPaths).not.toContain("/src/utils/helper.py");

      const memListing = await composite.lsInfo("/memories/");
      const memPaths = memListing.map((fi) => fi.path);
      expect(memPaths).toContain("/memories/note1.txt");
      expect(memPaths).toContain("/memories/deep/");
      expect(memPaths).not.toContain("/memories/deep/note2.txt");

      const deepListing = await composite.lsInfo("/memories/deep/");
      const deepPaths = deepListing.map((fi) => fi.path);
      expect(deepPaths).toContain("/memories/deep/note2.txt");
      expect(deepPaths).toContain("/memories/deep/nested/");
      expect(deepPaths).not.toContain("/memories/deep/nested/note3.txt");
    } finally {
      await removeDir(tmpDir);
    }
  });
});</doc><doc title="Filesystem.Test" desc="docs page.">import { describe, it, expect, beforeEach, afterEach } from "vitest";
import * as fs from "fs/promises";
import * as fsSync from "fs";
import * as path from "path";
import * as os from "os";
import { FilesystemBackend } from "../../../src/backends/filesystem.js";

/**
 * Helper to write a file with automatic parent directory creation
 */
async function writeFile(filePath: string, content: string) {
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, content, "utf-8");
}

/**
 * Helper to create a unique temporary directory for each test
 */
function createTempDir(): string {
  return fsSync.mkdtempSync(path.join(os.tmpdir(), "deepagents-test-"));
}

/**
 * Helper to recursively remove a directory
 */
async function removeDir(dirPath: string) {
  try {
    await fs.rm(dirPath, { recursive: true, force: true });
  } catch (err) {
    // Ignore errors during cleanup
  }
}

describe("FilesystemBackend", () => {
  let tmpDir: string;

  beforeEach(() => {
    tmpDir = createTempDir();
  });

  afterEach(async () => {
    await removeDir(tmpDir);
  });

  it("should work in normal mode with absolute paths", async () => {
    const root = tmpDir;
    const f1 = path.join(root, "a.txt");
    const f2 = path.join(root, "dir", "b.py");
    await writeFile(f1, "hello fs");
    await writeFile(f2, "print('x')\nhello");

    const backend = new FilesystemBackend({
      rootDir: root,
      virtualMode: false,
    });

    const infos = await backend.lsInfo(root);
    const paths = new Set(infos.map((i) => i.path));
    expect(paths.has(f1)).toBe(true);
    expect(paths.has(f2)).toBe(false);
    expect(paths.has(path.join(root, "dir") + path.sep)).toBe(true);

    const txt = await backend.read(f1);
    expect(txt).toContain("hello fs");

    const editMsg = await backend.edit(f1, "fs", "filesystem", false);
    expect(editMsg).toBeDefined();
    expect(editMsg.error).toBeUndefined();
    expect(editMsg.occurrences).toBe(1);

    const writeMsg = await backend.write(
      path.join(root, "new.txt"),
      "new content"
    );
    expect(writeMsg).toBeDefined();
    expect(writeMsg.error).toBeUndefined();
    expect(writeMsg.path).toContain("new.txt");

    const matches = await backend.grepRaw("hello", root);
    expect(Array.isArray(matches)).toBe(true);
    if (Array.isArray(matches)) {
      expect(matches.some((m) => m.path.endsWith("a.txt"))).toBe(true);
    }

    const globResults = await backend.globInfo("**/*.py", root);
    expect(globResults.some((i) => i.path === f2)).toBe(true);
  });

  it("should work in virtual mode with sandboxed paths", async () => {
    const root = tmpDir;
    const f1 = path.join(root, "a.txt");
    const f2 = path.join(root, "dir", "b.md");
    await writeFile(f1, "hello virtual");
    await writeFile(f2, "content");

    const backend = new FilesystemBackend({
      rootDir: root,
      virtualMode: true,
    });

    const infos = await backend.lsInfo("/");
    const paths = new Set(infos.map((i) => i.path));
    expect(paths.has("/a.txt")).toBe(true);
    expect(paths.has("/dir/b.md")).toBe(false);
    expect(paths.has("/dir/")).toBe(true);

    const txt = await backend.read("/a.txt");
    expect(txt).toContain("hello virtual");

    const editMsg = await backend.edit("/a.txt", "virtual", "virt", false);
    expect(editMsg).toBeDefined();
    expect(editMsg.error).toBeUndefined();
    expect(editMsg.occurrences).toBe(1);

    const writeMsg = await backend.write("/new.txt", "x");
    expect(writeMsg).toBeDefined();
    expect(writeMsg.error).toBeUndefined();
    expect(fsSync.existsSync(path.join(root, "new.txt"))).toBe(true);

    const matches = await backend.grepRaw("virt", "/");
    expect(Array.isArray(matches)).toBe(true);
    if (Array.isArray(matches)) {
      expect(matches.some((m) => m.path === "/a.txt")).toBe(true);
    }

    const globResults = await backend.globInfo("**/*.md", "/");
    expect(globResults.some((i) => i.path === "/dir/b.md")).toBe(true);

    const err = await backend.grepRaw("[", "/");
    expect(typeof err).toBe("string");

    const traversalError = await backend.read("/../a.txt");
    expect(traversalError).toContain("Error");
    expect(traversalError).toContain("Path traversal not allowed");
  });

  it("should list nested directories correctly in virtual mode", async () => {
    const root = tmpDir;

    const files: Record<string, string> = {
      [path.join(root, "config.json")]: "config",
      [path.join(root, "src", "main.py")]: "code",
      [path.join(root, "src", "utils", "helper.py")]: "utils code",
      [path.join(root, "src", "utils", "common.py")]: "common utils",
      [path.join(root, "docs", "readme.md")]: "documentation",
      [path.join(root, "docs", "api", "reference.md")]: "api docs",
    };

    for (const [filePath, content] of Object.entries(files)) {
      await writeFile(filePath, content);
    }

    const backend = new FilesystemBackend({
      rootDir: root,
      virtualMode: true,
    });

    const rootListing = await backend.lsInfo("/");
    const rootPaths = rootListing.map((fi) => fi.path);
    expect(rootPaths).toContain("/config.json");
    expect(rootPaths).toContain("/src/");
    expect(rootPaths).toContain("/docs/");
    expect(rootPaths).not.toContain("/src/main.py");
    expect(rootPaths).not.toContain("/src/utils/helper.py");

    const srcListing = await backend.lsInfo("/src/");
    const srcPaths = srcListing.map((fi) => fi.path);
    expect(srcPaths).toContain("/src/main.py");
    expect(srcPaths).toContain("/src/utils/");
    expect(srcPaths).not.toContain("/src/utils/helper.py");

    const utilsListing = await backend.lsInfo("/src/utils/");
    const utilsPaths = utilsListing.map((fi) => fi.path);
    expect(utilsPaths).toContain("/src/utils/helper.py");
    expect(utilsPaths).toContain("/src/utils/common.py");
    expect(utilsPaths.length).toBe(2);

    const emptyListing = await backend.lsInfo("/nonexistent/");
    expect(emptyListing).toEqual([]);
  });

  it("should list nested directories correctly in normal mode", async () => {
    const root = tmpDir;

    const files: Record<string, string> = {
      [path.join(root, "file1.txt")]: "content1",
      [path.join(root, "subdir", "file2.txt")]: "content2",
      [path.join(root, "subdir", "nested", "file3.txt")]: "content3",
    };

    for (const [filePath, content] of Object.entries(files)) {
      await writeFile(filePath, content);
    }

    const backend = new FilesystemBackend({
      rootDir: root,
      virtualMode: false,
    });

    const rootListing = await backend.lsInfo(root);
    const rootPaths = rootListing.map((fi) => fi.path);
    expect(rootPaths).toContain(path.join(root, "file1.txt"));
    expect(rootPaths).toContain(path.join(root, "subdir") + path.sep);
    expect(rootPaths).not.toContain(path.join(root, "subdir", "file2.txt"));

    const subdirListing = await backend.lsInfo(path.join(root, "subdir"));
    const subdirPaths = subdirListing.map((fi) => fi.path);
    expect(subdirPaths).toContain(path.join(root, "subdir", "file2.txt"));
    expect(subdirPaths).toContain(path.join(root, "subdir", "nested") + path.sep);
    expect(subdirPaths).not.toContain(
      path.join(root, "subdir", "nested", "file3.txt")
    );
  });

  it("should handle trailing slashes consistently", async () => {
    const root = tmpDir;

    const files: Record<string, string> = {
      [path.join(root, "file.txt")]: "content",
      [path.join(root, "dir", "nested.txt")]: "nested",
    };

    for (const [filePath, content] of Object.entries(files)) {
      await writeFile(filePath, content);
    }

    const backend = new FilesystemBackend({
      rootDir: root,
      virtualMode: true,
    });

    const listingWithSlash = await backend.lsInfo("/");
    expect(listingWithSlash.length).toBeGreaterThan(0);

    const listing = await backend.lsInfo("/");
    const paths = listing.map((fi) => fi.path);
    expect(paths).toEqual([...paths].sort());

    const listing1 = await backend.lsInfo("/dir/");
    const listing2 = await backend.lsInfo("/dir");
    expect(listing1.length).toBe(listing2.length);
    expect(listing1.map((fi) => fi.path)).toEqual(
      listing2.map((fi) => fi.path)
    );

    const empty = await backend.lsInfo("/nonexistent/");
    expect(empty).toEqual([]);
  });

  it("should handle large file writes correctly", async () => {
    const root = tmpDir;
    const backend = new FilesystemBackend({
      rootDir: root,
      virtualMode: true,
    });

    const largeContent = "f".repeat(10000);
    const writeResult = await backend.write("/large_file.txt", largeContent);

    expect(writeResult.error).toBeUndefined();
    expect(writeResult.path).toBe("/large_file.txt");

    const readContent = await backend.read("/large_file.txt");
    expect(readContent).toContain(largeContent.substring(0, 100));

    const savedFile = path.join(root, "large_file.txt");
    expect(fsSync.existsSync(savedFile)).toBe(true);
  });
});</doc><doc title="State.Test" desc="docs page.">import { describe, it, expect, vi, beforeEach } from "vitest";
import { StateBackend } from "../../../src/backends/state.js";
import type { FileData } from "../../../src/backends/protocol.js";
import { getCurrentTaskInput, Command } from "@langchain/langgraph";
import { ToolMessage } from "@langchain/core/messages";

vi.mock("@langchain/langgraph", async (importOriginal) => {
  const actual = await importOriginal();
  return {
    ...(actual as any),
    getCurrentTaskInput: vi.fn(),
  };
});

/**
 * Helper to create a mock config with state
 */
function makeConfig(files: Record<string, FileData> = {}) {
  const state = {
    messages: [],
    files,
  };
  vi.mocked(getCurrentTaskInput).mockReturnValue(state);
  return {
    state,
    stateAndStore: { state, store: undefined },
    config: {},
  };
}

describe("StateBackend", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it("should write, read, edit, ls, grep, and glob", () => {
    const { state, stateAndStore } = makeConfig();
    const backend = new StateBackend(stateAndStore);

    const writeRes = backend.write("/notes.txt", "hello world");
    expect(writeRes).toBeDefined();
    expect(writeRes.error).toBeUndefined();
    expect(writeRes.filesUpdate).toBeDefined();

    Object.assign(state.files, writeRes.filesUpdate);

    const content = backend.read("/notes.txt");
    expect(content).toContain("hello world");

    const editRes = backend.edit("/notes.txt", "hello", "hi", false);
    expect(editRes).toBeDefined();
    expect(editRes.error).toBeUndefined();
    expect(editRes.filesUpdate).toBeDefined();
    Object.assign(state.files, editRes.filesUpdate);

    const content2 = backend.read("/notes.txt");
    expect(content2).toContain("hi world");

    const listing = backend.lsInfo("/");
    expect(listing.some((fi) => fi.path === "/notes.txt")).toBe(true);

    const matches = backend.grepRaw("hi", "/");
    expect(Array.isArray(matches)).toBe(true);
    if (Array.isArray(matches)) {
      expect(matches.some((m) => m.path === "/notes.txt")).toBe(true);
    }

    const err = backend.grepRaw("[", "/");
    expect(typeof err).toBe("string");

    const infos = backend.globInfo("*.txt", "/");
    expect(infos.some((i) => i.path === "/notes.txt")).toBe(true);
  });

  it("should handle errors correctly", () => {
    const { state, stateAndStore } = makeConfig();
    const backend = new StateBackend(stateAndStore);

    const editErr = backend.edit("/missing.txt", "a", "b");
    expect(editErr.error).toBeDefined();
    expect(editErr.error).toContain("not found");

    const writeRes = backend.write("/dup.txt", "x");
    expect(writeRes.filesUpdate).toBeDefined();
    Object.assign(state.files, writeRes.filesUpdate);

    const dupErr = backend.write("/dup.txt", "y");
    expect(dupErr.error).toBeDefined();
    expect(dupErr.error).toContain("already exists");
  });

  it("should list nested directories correctly", () => {
    const { state, stateAndStore } = makeConfig();
    const backend = new StateBackend(stateAndStore);

    const files: Record<string, string> = {
      "/src/main.py": "main code",
      "/src/utils/helper.py": "helper code",
      "/src/utils/common.py": "common code",
      "/docs/readme.md": "readme",
      "/docs/api/reference.md": "api reference",
      "/config.json": "config",
    };

    for (const [path, content] of Object.entries(files)) {
      const res = backend.write(path, content);
      expect(res.error).toBeUndefined();
      Object.assign(state.files, res.filesUpdate!);
    }

    const rootListing = backend.lsInfo("/");
    const rootPaths = rootListing.map((fi) => fi.path);
    expect(rootPaths).toContain("/config.json");
    expect(rootPaths).toContain("/src/");
    expect(rootPaths).toContain("/docs/");
    expect(rootPaths).not.toContain("/src/main.py");
    expect(rootPaths).not.toContain("/src/utils/helper.py");

    const srcListing = backend.lsInfo("/src/");
    const srcPaths = srcListing.map((fi) => fi.path);
    expect(srcPaths).toContain("/src/main.py");
    expect(srcPaths).toContain("/src/utils/");
    expect(srcPaths).not.toContain("/src/utils/helper.py");

    const utilsListing = backend.lsInfo("/src/utils/");
    const utilsPaths = utilsListing.map((fi) => fi.path);
    expect(utilsPaths).toContain("/src/utils/helper.py");
    expect(utilsPaths).toContain("/src/utils/common.py");
    expect(utilsPaths).toHaveLength(2);

    const emptyListing = backend.lsInfo("/nonexistent/");
    expect(emptyListing).toEqual([]);
  });

  it("should handle trailing slashes in ls", () => {
    const { state, stateAndStore } = makeConfig();
    const backend = new StateBackend(stateAndStore);

    const files: Record<string, string> = {
      "/file.txt": "content",
      "/dir/nested.txt": "nested",
    };

    for (const [path, content] of Object.entries(files)) {
      const res = backend.write(path, content);
      expect(res.error).toBeUndefined();
      Object.assign(state.files, res.filesUpdate!);
    }

    const listingWithSlash = backend.lsInfo("/");
    expect(listingWithSlash).toHaveLength(2);
    const rootPaths = listingWithSlash.map((fi) => fi.path);
    expect(rootPaths).toContain("/file.txt");
    expect(rootPaths).toContain("/dir/");

    const listingFromDir = backend.lsInfo("/dir/");
    expect(listingFromDir).toHaveLength(1);
    expect(listingFromDir[0].path).toBe("/dir/nested.txt");
  });

  it("should handle read with offset and limit", () => {
    const { state, stateAndStore } = makeConfig();
    const backend = new StateBackend(stateAndStore);

    const content = "line1\nline2\nline3\nline4\nline5";
    const writeRes = backend.write("/multiline.txt", content);
    Object.assign(state.files, writeRes.filesUpdate!);

    const readWithOffset = backend.read("/multiline.txt", 2, 2);
    expect(readWithOffset).toContain("line3");
    expect(readWithOffset).toContain("line4");
    expect(readWithOffset).not.toContain("line1");
    expect(readWithOffset).not.toContain("line5");
  });

  it("should handle edit with replace_all", () => {
    const { state, stateAndStore } = makeConfig();
    const backend = new StateBackend(stateAndStore);

    const writeRes = backend.write("/repeat.txt", "foo bar foo baz foo");
    Object.assign(state.files, writeRes.filesUpdate!);

    const editSingle = backend.edit("/repeat.txt", "foo", "qux", false);
    expect(editSingle.error).toBeDefined();
    expect(editSingle.error).toContain("appears 3 times");

    const editAll = backend.edit("/repeat.txt", "foo", "qux", true);
    expect(editAll.error).toBeUndefined();
    expect(editAll.occurrences).toBe(3);
    Object.assign(state.files, editAll.filesUpdate!);

    const readAfter = backend.read("/repeat.txt");
    expect(readAfter).toContain("qux bar qux baz qux");
    expect(readAfter).not.toContain("foo");
  });

  it("should handle grep with glob filter", () => {
    const { state, stateAndStore } = makeConfig();
    const backend = new StateBackend(stateAndStore);

    const files: Record<string, string> = {
      "/test.py": "import os",
      "/test.js": "import fs",
      "/readme.md": "import guide",
    };

    for (const [path, content] of Object.entries(files)) {
      const res = backend.write(path, content);
      Object.assign(state.files, res.filesUpdate!);
    }

    const matches = backend.grepRaw("import", "/", "*.py");
    expect(Array.isArray(matches)).toBe(true);
    if (Array.isArray(matches)) {
      expect(matches).toHaveLength(1);
      expect(matches[0].path).toBe("/test.py");
    }
  });

  it("should return empty content warning for empty files", () => {
    const { state, stateAndStore } = makeConfig();
    const backend = new StateBackend(stateAndStore);

    const writeRes = backend.write("/empty.txt", "");
    Object.assign(state.files, writeRes.filesUpdate!);

    const content = backend.read("/empty.txt");
    expect(content).toContain(
      "System reminder: File exists but has empty contents"
    );
  });

  it("should handle large tool result interception via middleware", async () => {
    const { stateAndStore, config } = makeConfig();
    const { createFilesystemMiddleware } = await import(
      "../../../src/middleware/fs.js"
    );

    const middleware = createFilesystemMiddleware({
      toolTokenLimitBeforeEvict: 1000,
    });

    const largeContent = "x".repeat(5000);
    const toolMessage = new ToolMessage({
      content: largeContent,
      tool_call_id: "test_123",
      name: "test_tool",
    });

    const mockToolFn = async () => toolMessage;
    const mockToolCall = { name: "test_tool", args: {}, id: "test_123" };

    const result = await (middleware as any).wrapToolCall(
      {
        toolCall: mockToolCall,
        config: config,
        state: { files: {}, messages: [] },
        runtime: {},
      },
      mockToolFn
    );

    expect(result).toBeInstanceOf(Command);
    expect(result.update.files).toBeDefined();
    expect(result.update.files["/large_tool_results/test_123"]).toBeDefined();
    expect(result.update.files["/large_tool_results/test_123"].content).toEqual(
      [largeContent]
    );

    expect(result.update.messages).toHaveLength(1);
    expect(result.update.messages[0].content).toContain(
      "Tool result too large"
    );
    expect(result.update.messages[0].content).toContain(
      "/large_tool_results/test_123"
    );
  });
});</doc><doc title="Store.Test" desc="docs page.">import { describe, it, expect } from "vitest";
import { StoreBackend } from "../../../src/backends/store.js";
import { InMemoryStore } from "@langchain/langgraph-checkpoint";

/**
 * Helper to create a mock config with InMemoryStore
 */
function makeConfig() {
  const store = new InMemoryStore();
  const stateAndStore = {
    state: { files: {}, messages: [] },
    store,
  };
  const config = {
    store,
    configurable: {},
  };

  return { store, stateAndStore, config };
}

describe("StoreBackend", () => {
  it("should handle CRUD and search operations", async () => {
    const { stateAndStore } = makeConfig();
    const backend = new StoreBackend(stateAndStore);

    const writeResult = await backend.write("/docs/readme.md", "hello store");
    expect(writeResult).toBeDefined();
    expect(writeResult.error).toBeUndefined();
    expect(writeResult.path).toBe("/docs/readme.md");
    expect(writeResult.filesUpdate).toBeNull();

    const content = await backend.read("/docs/readme.md");
    expect(content).toContain("hello store");

    const editResult = await backend.edit(
      "/docs/readme.md",
      "hello",
      "hi",
      false
    );
    expect(editResult).toBeDefined();
    expect(editResult.error).toBeUndefined();
    expect(editResult.occurrences).toBe(1);

    const infos = await backend.lsInfo("/docs/");
    expect(infos.some((i) => i.path === "/docs/readme.md")).toBe(true);

    const matches = await backend.grepRaw("hi", "/");
    expect(Array.isArray(matches)).toBe(true);
    if (Array.isArray(matches)) {
      expect(matches.some((m) => m.path === "/docs/readme.md")).toBe(true);
    }

    const glob1 = await backend.globInfo("*.md", "/");
    expect(glob1.length).toBe(0);

    const glob2 = await backend.globInfo("**/*.md", "/");
    expect(glob2.some((i) => i.path === "/docs/readme.md")).toBe(true);
  });

  it("should list nested directories correctly", async () => {
    const { stateAndStore } = makeConfig();
    const backend = new StoreBackend(stateAndStore);

    const files: Record<string, string> = {
      "/src/main.py": "main code",
      "/src/utils/helper.py": "helper code",
      "/src/utils/common.py": "common code",
      "/docs/readme.md": "readme",
      "/docs/api/reference.md": "api reference",
      "/config.json": "config",
    };

    for (const [path, content] of Object.entries(files)) {
      const res = await backend.write(path, content);
      expect(res.error).toBeUndefined();
    }

    const rootListing = await backend.lsInfo("/");
    const rootPaths = rootListing.map((fi) => fi.path);
    expect(rootPaths).toContain("/config.json");
    expect(rootPaths).toContain("/src/");
    expect(rootPaths).toContain("/docs/");
    expect(rootPaths).not.toContain("/src/main.py");
    expect(rootPaths).not.toContain("/src/utils/helper.py");
    expect(rootPaths).not.toContain("/docs/readme.md");
    expect(rootPaths).not.toContain("/docs/api/reference.md");

    const srcListing = await backend.lsInfo("/src/");
    const srcPaths = srcListing.map((fi) => fi.path);
    expect(srcPaths).toContain("/src/main.py");
    expect(srcPaths).toContain("/src/utils/");
    expect(srcPaths).not.toContain("/src/utils/helper.py");

    const utilsListing = await backend.lsInfo("/src/utils/");
    const utilsPaths = utilsListing.map((fi) => fi.path);
    expect(utilsPaths).toContain("/src/utils/helper.py");
    expect(utilsPaths).toContain("/src/utils/common.py");
    expect(utilsPaths).toHaveLength(2);

    const emptyListing = await backend.lsInfo("/nonexistent/");
    expect(emptyListing).toEqual([]);
  });

  it("should handle trailing slashes in ls", async () => {
    const { stateAndStore } = makeConfig();
    const backend = new StoreBackend(stateAndStore);

    const files: Record<string, string> = {
      "/file.txt": "content",
      "/dir/nested.txt": "nested",
    };

    for (const [path, content] of Object.entries(files)) {
      const res = await backend.write(path, content);
      expect(res.error).toBeUndefined();
    }

    const listingFromRoot = await backend.lsInfo("/");
    expect(listingFromRoot.length).toBeGreaterThan(0);

    const listing1 = await backend.lsInfo("/dir/");
    const listing2 = await backend.lsInfo("/dir");
    expect(listing1.length).toBe(listing2.length);
    expect(listing1.map((fi) => fi.path)).toEqual(
      listing2.map((fi) => fi.path)
    );
  });

  it("should handle errors correctly", async () => {
    const { stateAndStore } = makeConfig();
    const backend = new StoreBackend(stateAndStore);

    const editErr = await backend.edit("/missing.txt", "a", "b");
    expect(editErr.error).toBeDefined();
    expect(editErr.error).toContain("not found");

    const writeRes = await backend.write("/dup.txt", "x");
    expect(writeRes.error).toBeUndefined();

    const dupErr = await backend.write("/dup.txt", "y");
    expect(dupErr.error).toBeDefined();
    expect(dupErr.error).toContain("already exists");
  });

  it("should handle read with offset and limit", async () => {
    const { stateAndStore } = makeConfig();
    const backend = new StoreBackend(stateAndStore);

    const content = "line1\nline2\nline3\nline4\nline5";
    await backend.write("/multiline.txt", content);

    const readWithOffset = await backend.read("/multiline.txt", 2, 2);
    expect(readWithOffset).toContain("line3");
    expect(readWithOffset).toContain("line4");
    expect(readWithOffset).not.toContain("line1");
    expect(readWithOffset).not.toContain("line5");
  });

  it("should handle edit with replace_all", async () => {
    const { stateAndStore } = makeConfig();
    const backend = new StoreBackend(stateAndStore);

    await backend.write("/repeat.txt", "foo bar foo baz foo");

    const editSingle = await backend.edit("/repeat.txt", "foo", "qux", false);
    expect(editSingle.error).toBeDefined();
    expect(editSingle.error).toContain("appears 3 times");

    const editAll = await backend.edit("/repeat.txt", "foo", "qux", true);
    expect(editAll.error).toBeUndefined();
    expect(editAll.occurrences).toBe(3);

    const readAfter = await backend.read("/repeat.txt");
    expect(readAfter).toContain("qux bar qux baz qux");
    expect(readAfter).not.toContain("foo");
  });

  it("should handle grep with glob filter", async () => {
    const { stateAndStore } = makeConfig();
    const backend = new StoreBackend(stateAndStore);

    const files: Record<string, string> = {
      "/test.py": "import os",
      "/test.js": "import fs",
      "/readme.md": "import guide",
    };

    for (const [path, content] of Object.entries(files)) {
      await backend.write(path, content);
    }

    const matches = await backend.grepRaw("import", "/", "*.py");
    expect(Array.isArray(matches)).toBe(true);
    if (Array.isArray(matches)) {
      expect(matches).toHaveLength(1);
      expect(matches[0].path).toBe("/test.py");
    }
  });

  it("should return empty content warning for empty files", async () => {
    const { stateAndStore } = makeConfig();
    const backend = new StoreBackend(stateAndStore);

    await backend.write("/empty.txt", "");

    const content = await backend.read("/empty.txt");
    expect(content).toContain(
      "System reminder: File exists but has empty contents"
    );
  });

  it("should use custom namespace when assistant_id is provided", async () => {
    const { store } = makeConfig();
    const stateAndStoreWithAssistant = {
      state: { files: {}, messages: [] },
      store,
      assistantId: "test-assistant",
    };

    const backend = new StoreBackend(stateAndStoreWithAssistant);

    await backend.write("/test.txt", "content");

    const items = await store.search(["test-assistant", "filesystem"]);
    expect(items.some((item) => item.key === "/test.txt")).toBe(true);

    const defaultItems = await store.search(["filesystem"]);
    expect(defaultItems.some((item) => item.key === "/test.txt")).toBe(false);
  });

  it("should handle large tool result interception via middleware", async () => {
    const { store, config } = makeConfig();
    const { createFilesystemMiddleware } = await import(
      "../../../src/middleware/fs.js"
    );
    const { ToolMessage } = await import("@langchain/core/messages");

    const middleware = createFilesystemMiddleware({
      backend: (stateAndStore) => new StoreBackend(stateAndStore),
      toolTokenLimitBeforeEvict: 1000,
    });

    const largeContent = "y".repeat(5000);
    const toolMessage = new ToolMessage({
      content: largeContent,
      tool_call_id: "test_456",
      name: "test_tool",
    });

    const mockToolFn = async () => toolMessage;
    const mockToolCall = { name: "test_tool", args: {}, id: "test_456" };

    const result = await (middleware as any).wrapToolCall(
      {
        toolCall: mockToolCall,
        config: config,
        state: { files: {}, messages: [] },
        runtime: {},
      },
      mockToolFn
    );

    expect(result).toBeInstanceOf(ToolMessage);
    expect(result.content).toContain("Tool result too large");
    expect(result.content).toContain("/large_tool_results/test_456");

    const storedContent = await store.get(
      ["filesystem"],
      "/large_tool_results/test_456"
    );
    expect(storedContent).toBeDefined();
    expect((storedContent!.value as any).content).toEqual([largeContent]);
  });
});</doc></tests></project>
